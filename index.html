<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <title>Jeu Hitman - Prototype</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="theme-color" content="#020617">
    <style>
        :root {
            --bg: #050816;
            --bg-alt: #0f172a;
            --card: #020617;
            --accent: #38bdf8;
            --accent-soft: rgba(56, 189, 248, 0.15);
            --text: #e5e7eb;
            --text-muted: #9ca3af;
            --danger: #f97373;
            --hitman: #facc15;
            --success: #22c55e;
            --warning: #f59e0b;
            --radius-lg: 18px;
            --radius-md: 12px;
            --shadow-soft: 0 18px 35px rgba(15, 23, 42, 0.8);
            --shadow-sm: 0 8px 16px rgba(15, 23, 42, 0.65);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                sans-serif;
            background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            align-items: stretch;
            justify-content: center;
        }
        /* Variantes de fond selon l'humeur du jeu */
        body.mood-default {
            background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
        }

        body.mood-success {
            background: radial-gradient(circle at top, #022c22 0, #02201a 55%, #000 100%);
        }

        body.mood-fail {
            background: radial-gradient(circle at top, #3b0f1f 0, #200214 55%, #000 100%);
        }
        

        .app-shell {
            width: 100%;
            max-width: 480px;
            margin: 0 auto;
            padding: 16px 16px 24px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            position: relative;
            z-index: 1;
        }

        header {
            background: linear-gradient(135deg, rgba(15,23,42,0.96), rgba(8,47,73,0.96));
            border-radius: 24px;
            padding: 14px 18px 12px;
            box-shadow: var(--shadow-soft);
            border: 1px solid rgba(148, 163, 184, 0.25);
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 12px;
            z-index: 10;
            backdrop-filter: blur(16px);
        }

        .title-block {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .title {
            font-size: 1.15rem;
            font-weight: 650;
            letter-spacing: 0.03em;
        }

        .subtitle {
            font-size: 0.78rem;
            color: var(--text-muted);
        }

        .badge-beta {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.5);
            background: radial-gradient(circle at top left, rgba(56,189,248,0.35), transparent 55%);
            color: var(--text);
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .screen {
            display: none;
            flex-direction: column;
            gap: 16px;
            margin-top: 8px;
        }

        .screen.active {
            display: flex;
        }

        .card {
            background: radial-gradient(circle at top left, rgba(56,189,248,0.06), transparent 55%),
                        linear-gradient(145deg, rgba(15,23,42,0.96), rgba(2,6,23,0.96));
            border-radius: var(--radius-lg);
            padding: 18px 16px 16px;
            box-shadow: var(--shadow-soft);
            border: 1px solid rgba(30, 64, 175, 0.7);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
        }

        .card-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .card-subtitle {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .hint {
            font-size: 0.78rem;
            color: var(--text-muted);
        }

        .input-row {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            font-size: 0.86rem;
            color: var(--text-muted);
        }

        select,
        input[type="text"],
        input[type="number"] {
            width: 100%;
            border-radius: var(--radius-md);
            border: 1px solid rgba(148, 163, 184, 0.4);
            background: rgba(15, 23, 42, 0.95);
            color: var(--text);
            padding: 9px 11px;
            font-size: 0.92rem;
            outline: none;
            box-shadow: var(--shadow-sm);
        }

        select:focus,
        input[type="text"]:focus,
        input[type="number"]:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.5);
        }

        .players-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
            max-height: 280px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .player-input-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-index {
            width: 26px;
            height: 26px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.78rem;
            color: var(--text-muted);
            background: radial-gradient(circle at top, rgba(148,163,184,0.5), transparent 55%);
            flex-shrink: 0;
        }

        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .btn {
            appearance: none;
            border: none;
            border-radius: 999px;
            padding: 10px 15px;
            font-size: 0.9rem;
            font-weight: 550;
            letter-spacing: 0.04em;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            text-transform: uppercase;
        }

        .btn-primary {
            background: radial-gradient(circle at top, #38bdf8, #0ea5e9);
            color: #0b1120;
            box-shadow: 0 12px 24px rgba(56, 189, 248, 0.4);
        }

        .btn-primary:active {
            transform: translateY(1px);
            box-shadow: 0 6px 12px rgba(56, 189, 248, 0.5);
        }

        .btn-ghost {
            background: rgba(15, 23, 42, 0.85);
            color: var(--text-muted);
            border: 1px solid rgba(148, 163, 184, 0.5);
        }

        .btn-full {
            width: 100%;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
        }

        .pill-hitman {
            background: radial-gradient(circle at top left, rgba(250, 204, 21, 0.45), transparent 60%);
            border: 1px solid rgba(250, 204, 21, 0.9);
            color: #facc15;
        }

        .pill-civil {
            background: radial-gradient(circle at top left, rgba(34, 197, 94, 0.5), transparent 60%);
            border: 1px solid rgba(34, 197, 94, 0.9);
            color: #bbf7d0;
        }

        .pass-instruction {
            font-size: 0.9rem;
        }

        .pass-highlight {
            font-weight: 600;
            color: var(--accent);
        }

        .profile-card {
            margin-top: 6px;
            border-radius: var(--radius-md);
            background: rgba(15, 23, 42, 0.98);
            padding: 10px 11px;
            border: 1px solid rgba(30, 64, 175, 0.8);
        }
        #clueText,
        .profile-card,
        .profile-card * {
            color: var(--text) !important;
        }

        /* Lisibilit√© des indices et cartes d'info */
        .profile-card,
        .profile-card p,
        .profile-card li,
        .clue-card,
        .clue-card p,
        .clue-card span {
            color: var(--text);
        }


        .profile-title {
            font-size: 0.86rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .profile-list {
            list-style: none;
            padding: 0;
            margin: 4px 0 0 0;
            font-size: 0.86rem;
        }

        .profile-list li {
            margin-bottom: 2px;
        }

        .contract-tagline {
            font-size: 0.78rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .contract-highlight {
            font-weight: 600;
            color: var(--hitman);
        }

        .summary-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }

        .summary-badge {
            font-size: 0.74rem;
            border-radius: 999px;
            padding: 3px 8px;
            border: 1px solid rgba(148, 163, 184, 0.5);
            color: var(--text-muted);
        }

        .footer-note {
            font-size: 0.72rem;
            color: var(--text-muted);
            text-align: center;
            margin-top: 2px;
        }

        @media (max-width: 480px) {
            header {
                padding: 10px 12px;
                border-radius: 18px;
            }
            .card {
                padding: 14px 12px 12px;
                border-radius: 16px;
            }
        }

        /* ========== ANIMATIONS GLOBALES ========== */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(16px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulseSoft {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(56,189,248,0.4); }
            50% { transform: scale(1.03); box-shadow: 0 0 0 6px rgba(56,189,248,0); }
        }

        @keyframes shake {
            0%,100% { transform: translateX(0); }
            25% { transform: translateX(-3px); }
            75% { transform: translateX(3px); }
        }

        .screen.active .card {
            animation: fadeInUp 0.35s ease-out;
        }

        /* Timer rond en haut √† droite pendant le mini-jeu */
        .timer-container {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(15,23,42,0.98);
            border: 2px solid var(--accent);
            border-radius: 999px;
            width: 56px;
            height: 56px;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--accent);
            z-index: 200;
            animation: pulseSoft 1.6s infinite;
        }

        .timer-container.urgent {
            border-color: var(--danger);
            color: var(--danger);
            animation: shake 0.6s infinite;
        }

        /* Carte d'indice anim√©e */
        .clue-card {
            background: linear-gradient(135deg, rgba(56,189,248,0.12), rgba(15,23,42,0.9));
            border: 1px solid rgba(56,189,248,0.6);
            border-radius: var(--radius-md);
            padding: 8px 10px;
            margin-bottom: 6px;
            font-size: 0.85rem;
            animation: fadeInUp 0.25s ease-out;
        }

        /* Boutons un peu plus vivants */
        .btn-primary {
            transition: transform 0.08s ease-out, box-shadow 0.1s ease-out, filter 0.1s ease-out;
        }

        .btn-primary:hover {
            filter: brightness(1.05);
            transform: translateY(-1px);
        }

        .btn-primary:active {
            transform: translateY(1px) scale(0.98);
        }

        .memory-card {
            transition: transform 0.08s ease-out, box-shadow 0.12s ease-out, background 0.1s;
        }

        .memory-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(15,23,42,0.7);
        }
        /* ========== NOUVEAUX STYLES V2.0 ========== */

        /* Tableau de d√©duction */
        .deduction-table {
            overflow-x: auto;
            margin-top: 10px;
        }

        .deduction-grid {
            display: grid;
            grid-template-columns: auto repeat(4, 1fr);
            gap: 4px;
            font-size: 0.75rem;
            min-width: 100%;
        }

        .deduction-cell {
            padding: 6px 4px;
            text-align: center;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 4px;
        }

        .deduction-header {
            font-weight: 600;
            background: rgba(56, 189, 248, 0.1);
            border-color: rgba(56, 189, 248, 0.4);
        }

        .deduction-player {
            font-weight: 600;
            text-align: left;
            padding-left: 8px;
        }

        /* Indicateurs de fiabilit√© */
        .reliability-verified {
            color: var(--success);
        }

        .reliability-claimed {
            color: var(--warning);
        }

        .reliability-suspicious {
            color: var(--danger);
        }

        /* Questions √† choix multiples */
        .mcq-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .mcq-option {
            padding: 12px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            border-radius: var(--radius-md);
            background: rgba(15, 23, 42, 0.6);
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .mcq-option:hover {
            border-color: var(--accent);
            background: rgba(56, 189, 248, 0.1);
        }

        .mcq-option.selected {
            border-color: var(--accent);
            background: rgba(56, 189, 248, 0.2);
        }

        .mcq-option.correct {
            border-color: var(--success);
            background: rgba(34, 197, 94, 0.2);
        }

        .mcq-option.incorrect {
            border-color: var(--danger);
            background: rgba(249, 115, 115, 0.2);
        }

        /* Badge de capacit√© sp√©ciale */
        .special-ability-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 0.7rem;
            background: rgba(250, 204, 21, 0.2);
            border: 1px solid rgba(250, 204, 21, 0.6);
            color: var(--hitman);
        }

        .special-ability-badge.used {
            opacity: 0.5;
            text-decoration: line-through;
        }

        /* Filtres du journal */
        .journal-filters {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .filter-btn {
            padding: 4px 10px;
            font-size: 0.75rem;
            border: 1px solid rgba(148, 163, 184, 0.4);
            background: rgba(15, 23, 42, 0.8);
            color: var(--text-muted);
            border-radius: 999px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .filter-btn.active {
            background: var(--accent);
            color: #0b1120;
            border-color: var(--accent);
        }
    </style>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>
<body>
<body class="mood-default">
<div id="bg3d-container" style="
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
    overflow: hidden;
"></div>
<div class="app-shell">
    <!-- Timer de tour (mini-jeu) -->
    <div id="turnTimer" class="timer-container">
        <span id="turnTimerValue">45</span>
    </div>
    <header>
        <div class="title-block">
            <div class="title">Hitman Social</div>
            <div class="subtitle">Version am√©lior√©e</div>
        </div>
        <div class="badge-beta">v2.5.5</div>
    </header>

    <main>
        <!-- √âcran 1 : configuration initiale -->
        <section id="screen-setup" class="screen active">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">Nouvelle partie</div>
                        <div class="card-subtitle">
                            Choisis le nombre de joueurs, puis leurs noms.
                        </div>
                    </div>
                </div>

                <div class="input-row">
                    <label for="playerCount">Nombre de joueurs (3 √† 8)</label>
                    <select id="playerCount">
                        <option value="3">3 joueurs</option>
                        <option value="4">4 joueurs</option>
                        <option value="5">5 joueurs</option>
                        <option value="6">6 joueurs</option>
                        <option value="7">7 joueurs</option>
                        <option value="8">8 joueurs</option>
                    </select>
                </div>

                <div class="btn-row">
                    <button class="btn btn-primary btn-full" id="btnSetupNext">
                        Continuer
                    </button>
                </div>
                <p class="hint">
                    Le jeu se joue sur <strong>un seul t√©l√©phone</strong> que vous
                    passerez de joueur en joueur.
                </p>
            </div>
        </section>

        <!-- √âcran 2 : saisie des noms -->
        <section id="screen-names" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">Noms des joueurs</div>
                        <div class="card-subtitle">
                            Facultatif, mais conseill√© pour s'y retrouver.
                        </div>
                    </div>
                </div>

                <div id="playersContainer" class="players-grid"></div>

                <div class="btn-row">
                    <button class="btn btn-ghost" id="btnNamesBack">Retour</button>
                    <button class="btn btn-primary" id="btnStartGame">
                        Lancer la partie
                    </button>
                </div>

                <p class="hint">
                    Si tu laisses un nom vide, il sera remplac√© par "Joueur X".
                </p>
            </div>
        </section>

        <!-- √âcran 3 : passer le t√©l√©phone -->
        <section id="screen-pass" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">Passer le t√©l√©phone</div>
                        <div class="card-subtitle">
                            Chaque joueur va regarder son r√¥le √† tour de r√¥le.
                        </div>
                    </div>
                </div>

                <p class="pass-instruction">
                    Passe maintenant le t√©l√©phone √†
                    <span class="pass-highlight" id="passPlayerName"></span>.
                    Lorsque la personne est pr√™te, appuie sur le bouton ci-dessous.
                </p>

                <div class="btn-row" style="margin-top: 14px;">
                    <button class="btn btn-primary btn-full" id="btnRevealForPlayer">
                        C'est bon, je suis pr√™t
                    </button>
                </div>

                <p class="hint">
                    Les autres joueurs ne doivent pas regarder l'√©cran pendant cette
                    √©tape.
                </p>
            </div>
        </section>

        <!-- √âcran 4 : vue du joueur (r√¥le + profil) -->
        <section id="screen-player-view" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title" id="playerViewTitle"></div>
                        <div class="card-subtitle" id="playerViewSubtitle"></div>
                    </div>
                    <div id="rolePill"></div>
                </div>

                <div id="playerViewContent"></div>

                <div class="btn-row" style="margin-top: 14px;">
                    <button class="btn btn-primary btn-full" id="btnPlayerDone">
                        J'ai compris, passer le t√©l√©phone
                    </button>
                </div>

                <p class="hint">
                    Ne montre pas ces informations aux autres joueurs.
                </p>
            </div>
        </section>

        <!-- √âcran 5 : r√©sum√© fin de distribution -->
        <section id="screen-summary" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">Distribution termin√©e</div>
                        <div class="card-subtitle">
                            Tous les r√¥les et profils ont √©t√© attribu√©s.
                        </div>
                    </div>
                </div>

                <p>
                    Vous pouvez maintenant d√©marrer la partie ! Un joueur est le tueur, les autres sont des civils.
                </p>

                <div class="profile-card">
                    <div class="profile-title">üéØ Nouveaut√©s de cette version</div>
                    <ul class="profile-list">
                        <li>‚Ä¢ <strong>Questions √† choix multiples</strong> (plus strat√©giques)</li>
                        <li>‚Ä¢ <strong>Syst√®me de t√©moins</strong> (interroger les autres)</li>
                        <li>‚Ä¢ <strong>Tableau de d√©duction</strong> pour organiser les indices</li>
                        <li>‚Ä¢ Le Hitman peut <strong>bluffer</strong> avec des faux indices !</li>
                    </ul>
                </div>

                <div class="summary-badges" id="summaryBadges"></div>

                <div class="btn-row" style="margin-top: 14px;">
                    <button class="btn btn-ghost btn-full" id="btnRestart">
                        Recommencer une nouvelle partie
                    </button>
                </div>
            </div>
            <div class="footer-note">
                Version prototype : prochainement, ajout des phases d'enqu√™te,
                indices, √©liminations et votes.
            </div>
        </section>
        <!-- √âcran 6 : Phase Investigation (passage du t√©l√©phone) -->
        <section id="screen-investigation" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">Round <span id="roundNumber">1</span> - Investigation</div>
                        <div class="card-subtitle">Passe le t√©l√©phone au joueur suivant</div>
                    </div>
                </div>
                
                <p class="pass-instruction">
                    C'est au tour de <span class="pass-highlight" id="investigationPlayerName"></span>.
                    <br><br>
                    <strong>R√®gle :</strong> Prends le t√©l√©phone, regarde ton profil, puis joue un mini-jeu pour gagner un indice.
                </p>
                
                <div class="btn-row">
                    <button class="btn btn-primary btn-full" id="btnStartTurn">
                        C'est mon tour, je prends le t√©l√©phone
                    </button>
                </div>
            </div>
        </section>

        <!-- √âcran 7 : Action du joueur (profil + mini-jeu) -->
        <section id="screen-player-turn" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title" id="turnPlayerTitle"></div>
                        <div class="card-subtitle">Ton profil et ton action</div>
                    </div>
                </div>
                
                <div id="turnPlayerProfile" class="profile-card" style="margin-bottom: 12px;">
                    <!-- Profil inject√© ici -->
                </div>
                
                <div id="playerClues" class="profile-card" style="margin-bottom: 10px; display:none;">
                    <div class="profile-title">Tes indices pr√©c√©dents</div>
                    <div id="playerCluesList">
                        <!-- Indices pour ce joueur -->
                    </div>
                </div>
                <!-- NOUVEAU : Choix de l'action -->
                <div id="actionChoice" style="display: none;">
                    <div class="card" style="border-color: rgba(56,189,248,0.5); margin-bottom: 12px;">
                        <div class="card-title" style="font-size: 0.9rem; margin-bottom: 8px;">üéØ Choisis ton action</div>
                        <div class="mcq-options">
                            <button class="mcq-option" id="btnActionMinigame">
                                üéÆ <strong>Jouer au mini-jeu</strong>
                                <div style="font-size:0.75rem;color:var(--text-muted);margin-top:2px;">
                                    Gagne un indice sur un joueur al√©atoire
                                </div>
                            </button>
                            <button class="mcq-option" id="btnActionWitness">
                                üó£Ô∏è <strong>Interroger un joueur</strong>
                                <div style="font-size:0.75rem;color:var(--text-muted);margin-top:2px;">
                                    Pose une question directe (r√©ponse obligatoire)
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
                <!-- NOUVEAU : Syst√®me de t√©moins -->
                <div id="witnessSystem" style="display: none;">
                    <div class="card" style="border-color: rgba(56,189,248,0.5); margin-bottom: 12px;">
                        <div class="card-title" style="font-size: 0.9rem; margin-bottom: 8px;">üó£Ô∏è Interroger un joueur</div>
                        <p style="font-size:0.85rem;margin-bottom:10px;">Choisis un joueur et pose-lui une question. Il doit r√©pondre honn√™tement !</p>
                        
                        <label style="font-size:0.8rem;margin-bottom:4px;display:block;">Quel joueur veux-tu interroger ?</label>
                        <select id="witnessTargetSelect" style="margin-bottom:10px;">
                            <option value="">-- Choisir un joueur --</option>
                        </select>

                        <label style="font-size:0.8rem;margin-bottom:4px;display:block;">Quelle question veux-tu poser ?</label>
                        <select id="witnessQuestionSelect" style="margin-bottom:10px;">
                            <option value="">-- Choisir une question --</option>
                            <option value="gender">Quel est ton genre ?</option>
                            <option value="accessory">Quel accessoire portes-tu ?</option>
                            <option value="job">Quel est ton m√©tier ?</option>
                            <option value="trait">Quel est ton trait de caract√®re ?</option>
                        </select>

                        <button class="btn btn-primary btn-full" id="btnAskWitness">
                            Poser la question
                        </button>
                    </div>
                </div>

                <div id="witnessAnswer" style="display: none; margin-bottom: 12px;">
                    <!-- R√©ponse du t√©moin -->
                </div>
                <div id="minigameContainer" style="display: none;">
                    <div class="card" style="border-color: rgba(250,204,21,0.5);">
                        <div class="card-title" style="font-size: 0.9rem; margin-bottom: 8px;">üéÆ Mini-jeu pour gagner un indice</div>
                        <div id="minigameContent"></div>
                    </div>
                </div>
                <div id="witnessAction" style="display:none; margin-top:10px;">
                    <div class="card" style="border-color:rgba(249,250,115,0.6); background:radial-gradient(circle at top left, rgba(250,250,115,0.1), transparent 55%);">
                      <div class="card-title" style="font-size:0.9rem;">üëÅÔ∏è Appeler un t√©moin</div>
                      <p style="font-size:0.8rem;margin:4px 0 8px;">
                        Une fois par partie, tu peux obtenir un <strong>indice fiable</strong> sans mini‚Äëjeu.
                      </p>
                      <button class="btn btn-primary btn-full" id="btnUseWitness">
                        Utiliser mon t√©moin
                      </button>
                    </div>
                </div>                  
                <div id="clueReveal" style="display:none;margin-top:12px;" class="profile-card">
                    <div class="profile-title">üîç Indice d√©couvert</div>
                    <p id="clueText" style="margin:4px 0;font-size:0.9rem;"></p>
                    
                    <div id="clueActionsRow" class="btn-row" style="margin-top:10px;display:none;">
                        <button class="btn btn-primary" id="btnRevealClue">
                        R√©v√©ler au journal
                        </button>
                        <button class="btn btn-ghost" id="btnKeepClue">
                        Garder pour moi
                        </button>
                    </div>
                </div>
                
                <div id="hitmanAction" style="display: none; margin-top: 12px;">
                    <div class="card" style="border-color: rgba(249,115,115,0.6); background: radial-gradient(circle at top left, rgba(249,115,115,0.1), transparent 50%);">
                        <div class="card-title" style="color: var(--danger); font-size: 0.9rem; margin-bottom: 8px;">
                            üó°Ô∏è Actions du Hitman
                        </div>
                
                        <!-- Capacit√©s sp√©ciales -->
                        <div id="hitmanSpecialAbilities" style="margin-bottom: 12px;">
                            <p style="font-size:0.8rem;margin-bottom:6px;">Capacit√©s sp√©ciales :</p>
                            <div style="display:flex;flex-direction:column;gap:6px;">
                                <button class="btn btn-ghost btn-full" id="btnPlantFakeClue" style="font-size:0.8rem;padding:8px 12px;">
                                    <span class="special-ability-badge" id="fakeClueAbility">üé≠ Planter un faux indice</span>
                                </button>
                            </div>
                        </div>
                
                        <hr style="border:none;border-top:1px solid rgba(148,163,184,0.2);margin:12px 0;">
                
                        <p style="font-size: 0.85rem; margin: 6px 0;">Tu peux tenter d'√©liminer un joueur. Si tu te trompes, un de tes attributs sera r√©v√©l√© !</p>
                        <select id="hitmanTargetSelect" style="margin-top: 8px; margin-bottom: 8px;">
                            <option value="">-- Choisir une cible --</option>
                        </select>
                        <button class="btn btn-primary" id="btnAttemptKill" style="background: var(--danger); box-shadow: 0 8px 16px rgba(249,115,115,0.4);">
                            TENTER L'√âLIMINATION
                        </button>
                    </div>
                </div>
                
                <div class="btn-row" style="margin-top: 14px;">
                    <button class="btn btn-ghost" id="btnBackToInvestigation" style="display: none;">Retour</button>
                    <button class="btn btn-primary btn-full" id="btnEndTurn" style="display: none;">
                        Terminer mon tour (passer le t√©l√©phone)
                    </button>
                </div>
            </div>
        </section>

        <!-- √âcran 8 : Journal de bord -->
        <section id="screen-journal" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">üìì Journal de bord</div>
                        <div class="card-subtitle">Indices collect√©s ‚Äì discutez avant de voter</div>
                    </div>
                </div>
                <!-- NOUVEAU : Onglets Vue Liste / Vue Tableau -->
                <div style="display:flex;gap:8px;margin-bottom:12px;">
                    <button class="filter-btn active" id="btnViewList">üìã Liste</button>
                    <button class="filter-btn" id="btnViewTable">üìä Tableau</button>
                </div>
                <!-- NOUVEAU : Filtres -->
                <div class="journal-filters" id="journalFilters">
                    <button class="filter-btn active" data-filter="all">Tous</button>
                    <button class="filter-btn" data-filter="gender">Genre</button>
                    <button class="filter-btn" data-filter="accessory">Accessoire</button>
                    <button class="filter-btn" data-filter="job">M√©tier</button>
                    <button class="filter-btn" data-filter="trait">Caract√®re</button>
                </div>
                <!-- Vue Liste -->
                <div id="journalListView" style="max-height: 300px; overflow-y: auto;">
                    <div id="journalEntries">
                        <p class="hint" style="text-align: center; padding: 20px;">Aucun indice pour le moment...</p>
                    </div>
                </div>

                <!-- NOUVEAU : Vue Tableau de d√©duction -->
                <div id="journalTableView" style="display:none;">
                    <div class="deduction-table">
                        <div id="deductionGrid" class="deduction-grid">
                            <!-- Tableau g√©n√©r√© dynamiquement -->
                        </div>
                    </div>
                    <p class="hint" style="margin-top:8px;font-size:0.7rem;">
                        <span class="reliability-verified">‚úì V√©rifi√©</span> ¬∑ 
                        <span class="reliability-claimed">‚ö† D√©clar√©</span> ¬∑ 
                        <span class="reliability-suspicious">‚úó Suspect</span>
                    </p>
                </div>
                
                <p class="hint" style="margin-top:8px;">
                    Prenez quelques minutes pour discuter ensemble de ces indices avant de passer au vote.
                </p>
                
                <div class="btn-row" style="margin-top: 14px;">
                    <button class="btn btn-primary btn-full" id="btnGoToVote">
                        Passer au vote
                    </button>
                </div>

                <div class="btn-row" style="margin-top: 6px;">
                    <button class="btn btn-ghost btn-full" id="btnSkipVote">
                        Sauter ce vote (personne n'est √©limin√©)
                    </button>
                </div>
            </div>
        </section>

        <!-- √âcran 9 : Vote -->
        <section id="screen-vote" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">üó≥Ô∏è Phase de Vote</div>
                        <div class="card-subtitle">Chacun vote pour qui il suspecte</div>
                    </div>
                </div>
                
                <p class="hint">S√©lectionne le joueur que tu souhaites √©liminer. Les votes seront r√©v√©l√©s simultan√©ment.</p>
                
                <div id="voteButtons" class="players-grid" style="margin-top: 12px;">
                    <!-- Boutons de vote g√©n√©r√©s ici -->
                </div>
                
                <div id="voteConfirmation" style="display: none; margin-top: 12px; text-align: center;">
                    <p style="color: var(--accent); font-weight: 600;">Tu as vot√© pour <span id="votedPlayerName"></span></p>
                    <p class="hint">Attends que tous les joueurs aient vot√©...</p>
                </div>
                
                <div class="btn-row" style="margin-top: 14px;">
                    <button class="btn btn-primary btn-full" id="btnRevealVotes" style="display: none;">
                        R√©v√©ler les votes
                    </button>
                </div>
            </div>
        </section>

        <!-- √âcran 10 : R√©solution du vote -->
        <section id="screen-resolution" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">üìä R√©sultat du vote</div>
                        <div class="card-subtitle" id="resolutionSubtitle"></div>
                    </div>
                </div>
                
                <div id="voteResults"></div>
                
                <div id="eliminationReveal" style="margin-top: 16px; display: none;">
                    <div class="profile-card" id="eliminatedCard">
                        <!-- Info du joueur √©limin√© -->
                    </div>
                </div>
                
                <div class="btn-row" style="margin-top: 16px;">
                    <button class="btn btn-primary btn-full" id="btnNextRound">
                        Continuer
                    </button>
                </div>
            </div>
        </section>

        <!-- √âcran 11 : Fin de partie -->
        <section id="screen-end" class="screen">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title" id="endTitle">Partie termin√©e</div>
                        <div class="card-subtitle" id="endSubtitle"></div>
                    </div>
                </div>
                
                <div id="endContent" style="margin-top: 8px;"></div>
                
                <div class="btn-row" style="margin-top: 16px;">
                    <button class="btn btn-primary btn-full" id="btnNewGame">
                        Nouvelle partie
                    </button>
                </div>
            </div>
        </section>        
    </main>
</div>

<script>
(function () {
    const genders = ["Homme", "Femme"];
    const accessories = ["Lunettes", "Chapeau", "Boucle d'oreille", "Tatouage"];
    const jobs = ["Scientifique", "Artiste", "Policier", "Journaliste", "M√©decin"];
    const traits = ["Calme", "Nerveux", "Myst√©rieux", "Extraverti"];

    const state = {
        numPlayers: 3,
        players: [],
        hitmanIndex: null,
        targetIndex: null,
        contractAttributes: [],
        currentRevealIndex: 0,
        witnessUses: {}, // key = playerIndex, value = true/false
        
        // NOUVEAU : gestion des rounds
        gamePhase: 'setup', // setup, reveal, investigation, vote, resolution, end
        currentRound: 0,
        maxRounds: 6,
        currentPlayerTurn: 0, // index du joueur dont c'est le tour en phase investigation
        investigationOrder: [], // ordre al√©atoire des joueurs par round
        journal: [], // {round, player, type, content, target}
        lastClueIndex: null,
        eliminatedPlayers: [], // indices des joueurs √©limin√©s
        hitmanAttempted: false, // le hitman a-t-il tent√© d'√©liminer ce round ?
        hitmanSuccess: false,
        turnTimerId: null,
        turnTimeLeft: 45,
        clueGivenThisTurn: false,
        votes: {}, // playerId -> votedPlayerId
        gameOver: false,
        winner: null, // 'hitman' ou 'civils'
        // NOUVEAU v2.0
        hitmanAbilities: {
            fakeClueUsed: false,
            fakeCluesRemaining: 1
        },
        currentJournalFilter: 'all',
        currentJournalView: 'list', // 'list' ou 'table'
        witnessAsked: false,
        witnessAnswer: null
    };


    // Helpers DOM
    const $ = (id) => document.getElementById(id);

    function showScreen(id) {
        const screens = document.querySelectorAll(".screen");
        screens.forEach((s) => s.classList.remove("active"));
        const screen = $(id);
        if (screen) screen.classList.add("active");
    }

    function createPlayersInputs() {
        const container = $("playersContainer");
        container.innerHTML = "";
        for (let i = 0; i < state.numPlayers; i++) {
            const row = document.createElement("div");
            row.className = "player-input-row";

            const badge = document.createElement("div");
            badge.className = "player-index";
            badge.textContent = i + 1;

            const input = document.createElement("input");
            input.type = "text";
            input.placeholder = "Nom du joueur " + (i + 1);
            input.dataset.index = i;

            row.appendChild(badge);
            row.appendChild(input);
            container.appendChild(row);
        }
    }

    function readPlayerNames() {
        const inputs = $("playersContainer").querySelectorAll("input[type='text']");
        const players = [];
        inputs.forEach((input, idx) => {
            const raw = input.value.trim();
            const name = raw || "Joueur " + (idx + 1);
            players.push({
                id: idx,
                name,
                role: null,
                profile: null,
                clues: [] // NOUVEAU : stocke les indices personnels du joueur
            });
        });
        state.players = players;
    }

    function randomFrom(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    function generateProfiles() {
        for (let p of state.players) {
            p.profile = {
                gender: randomFrom(genders),
                accessory: randomFrom(accessories),
                job: randomFrom(jobs),
                trait: randomFrom(traits)
            };
        }
    }

    function assignRolesAndContract() {
        const n = state.players.length;
        const hitmanIndex = Math.floor(Math.random() * n);
        state.hitmanIndex = hitmanIndex;

        // Assign roles
        state.players.forEach((p, idx) => {
            p.role = idx === hitmanIndex ? "hitman" : "civil";
        });

        // Choose target among others
        let targetIndex = Math.floor(Math.random() * (n - 1));
        if (targetIndex >= hitmanIndex) {
            targetIndex += 1;
        }
        state.targetIndex = targetIndex;

        const targetProfile = state.players[targetIndex].profile;

        // Pick 2 attributes randomly for the contract
        const keys = ["gender", "accessory", "job", "trait"];
        shuffleArray(keys);
        const contractAttrs = keys.slice(0, 2);
        state.contractAttributes = contractAttrs;
    }

    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }

    // G√©n√®re un indice sur un joueur al√©atoire (sauf soi-m√™me)
    function generateClue(forPlayerIndex) {
        const otherPlayers = state.players
        .map((p, idx) => ({...p, index: idx}))
        .filter(p => p.index !== forPlayerIndex && !state.eliminatedPlayers.includes(p.index));
    
        if (otherPlayers.length === 0) return null;
        
        const target = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
        const profile = target.profile;
        
        const attrs = ['gender', 'accessory', 'job', 'trait'];
        const attr = attrs[Math.floor(Math.random() * attrs.length)];
        let attrLabel, attrValue;
        
        switch(attr) {
            case 'gender': attrLabel = 'Genre'; attrValue = profile.gender; break;
            case 'accessory': attrLabel = 'Accessoire'; attrValue = profile.accessory; break;
            case 'job': attrLabel = 'M√©tier'; attrValue = profile.job; break;
            case 'trait': attrLabel = 'Caract√®re'; attrValue = profile.trait; break;
        }
        
        // AM√âLIORATION : R√©duire probabilit√© de faux indice de 15% √† 10%
        const isFalse = Math.random() < 0.10;
        const originalValue = attrValue;
        
        if (isFalse) {
            const possibleValues = attr === 'gender' ? genders : 
                                attr === 'accessory' ? accessories :
                                attr === 'job' ? jobs : traits;
            const otherValues = possibleValues.filter(v => v !== attrValue);
            attrValue = otherValues[Math.floor(Math.random() * otherValues.length)];
        }
        
        return {
            type: isFalse ? 'false_clue' : 'clue',
            targetPlayer: target.name,
            targetIndex: target.index,
            attribute: attrLabel,
            attributeKey: attr,
            value: attrValue,
            originalValue: originalValue,
            isFalse: isFalse,
            reliability: isFalse ? 'suspicious' : 'verified'
        };
    }
    // ========== V√âRIFICATION : Le Hitman peut-il se d√©couvrir lui-m√™me ? ==========
    // NON ! On doit l'exclure des indices g√©n√©r√©s et des questions pos√©es

    // Dans generateMultipleChoiceQuestion() :
    function generateMultipleChoiceQuestion(forPlayerIndex) {
        const otherPlayers = state.players
            .map((p, idx) => ({...p, index: idx}))
            .filter(p => p.index !== forPlayerIndex && !state.eliminatedPlayers.includes(p.index));
        
        // Le Hitman ne recevra jamais de question sur lui-m√™me ‚úÖ
        if (otherPlayers.length === 0) return null;
        
        const target = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
        const attrs = ['gender', 'accessory', 'job', 'trait'];
        const attr = attrs[Math.floor(Math.random() * attrs.length)];
        
        let attrLabel, correctValue, allValues;
        const profile = target.profile;
        
        switch(attr) {
            case 'gender': 
                attrLabel = 'Genre'; 
                correctValue = profile.gender;
                allValues = [...genders];
                break;
            case 'accessory': 
                attrLabel = 'Accessoire'; 
                correctValue = profile.accessory;
                allValues = [...accessories];
                break;
            case 'job': 
                attrLabel = 'M√©tier'; 
                correctValue = profile.job;
                allValues = [...jobs];
                break;
            case 'trait': 
                attrLabel = 'Caract√®re'; 
                correctValue = profile.trait;
                allValues = [...traits];
                break;
        }
        
        // G√©n√®re 3 options + l'option "Je ne sais pas"
        shuffleArray(allValues);
        let options = allValues.slice(0, 3);
        if (!options.includes(correctValue)) {
            options[Math.floor(Math.random() * 3)] = correctValue;
        }
        options.push("‚ùì Je ne sais pas");
        
        return {
            question: `Quel est le ${attrLabel.toLowerCase()} de ${target.name} ?`,
            options: options,
            correctAnswer: correctValue,
            targetPlayer: target.name,
            targetIndex: target.index,
            attribute: attrLabel,
            attributeKey: attr
        };
    }
    // V√©rifie les conditions de victoire
    function checkVictoryConditions() {
        // Victoire Hitman : cible √©limin√©e
        if (state.hitmanSuccess) {
            state.gameOver = true;
            state.winner = 'hitman';
            return true;
        }
        // Victoire Hitman : sa cible a √©t√© √©limin√©e (par vote ou autre)
        if (state.eliminatedPlayers.includes(state.targetIndex)) {
            state.gameOver = true;
            state.winner = 'hitman';
            return true;
        }

        // Victoire Hitman : survie jusqu'√† 2 joueurs restants
        const alivePlayers = state.players.filter((p, idx) => !state.eliminatedPlayers.includes(idx));
        if (alivePlayers.length <= 2 && !state.eliminatedPlayers.includes(state.hitmanIndex)) {
            state.gameOver = true;
            state.winner = 'hitman';
            return true;
        }
        
        // Victoire Civils : Hitman √©limin√© au vote
        if (state.eliminatedPlayers.includes(state.hitmanIndex)) {
            state.gameOver = true;
            state.winner = 'civils';
            return true;
        }
        
        // Victoire Civils : 6 rounds √©coul√©s sans victoire du hitman
        if (state.currentRound >= state.maxRounds) {
            state.gameOver = true;
            state.winner = 'civils';
            return true;
        }
        
        return false;
    }
    // Mini-jeu 1 : Memory (apparier couleurs)
    function generateMemoryGame() {
        const colors = ['üî¥', 'üîµ', 'üü¢', 'üü°', 'üü£', 'üü†'];
        const pairs = [...colors, ...colors];
        shuffleArray(pairs);
        return {
            type: 'memory',
            cards: pairs.map((icon, idx) => ({id: idx, icon, revealed: false, matched: false})),
            selected: [],
            matches: 0,
            attempts: 0
        };
    }

    // Mini-jeu 2 : R√©flexe (cliquer quand le cercle devient vert)
    function generateReflexGame() {
        return {
            type: 'reflex',
            state: 'instruction', // NOUVEAU : commence par les instructions
            startTime: 0,
            reactionTime: 0,
            timeoutId: null,
            clickedBeforeGreen: false
        };
    }

    function renderReflexGame() {
        currentMinigame = generateReflexGame();
        const container = $('minigameContent');
        
        // NOUVEAU : Afficher les instructions d'abord
        container.innerHTML = `
            <div style="text-align:center;padding:20px;">
                <div style="font-size:3rem;margin-bottom:12px;">‚ö°</div>
                <h3 style="margin:0 0 8px 0;font-size:1.1rem;">Test de R√©flexe</h3>
                <p style="margin:0 0 12px 0;font-size:0.85rem;color:var(--text-muted);">
                    Clique d√®s que le cercle devient vert !
                </p>
                <div style="background:var(--accent-soft);border:1px solid var(--accent);border-radius:12px;padding:10px;margin-bottom:16px;">
                    <p style="margin:0;font-size:0.8rem;color:var(--accent);">
                        <strong>üéØ Pour gagner :</strong> R√©agis en moins de 800ms
                    </p>
                    <p style="margin:6px 0 0 0;font-size:0.75rem;color:var(--danger);">
                        ‚ö†Ô∏è Si tu cliques avant le vert = √©chec !
                    </p>
                </div>
                <button class="btn btn-primary btn-full" id="btnStartReflex">
                    C'est parti ! üöÄ
                </button>
            </div>
        `;
        
        $('btnStartReflex').addEventListener('click', () => {
            startReflexGameActual();
        });
    }

    function startReflexGameActual() {
        const container = $('minigameContent');
        
        container.innerHTML = `
            <div style="text-align:center;">
                <div id="reflexCircle" style="width:120px;height:120px;border-radius:50%;background:#334155;margin:20px auto;transition:background 0.1s;border:4px solid rgba(148,163,184,0.3);"></div>
                <p id="reflexText" style="font-size:1.1rem;margin:16px 0;font-weight:600;">Pr√©pare-toi...</p>
                <p id="reflexHint" style="font-size:0.8rem;color:var(--text-muted);"></p>
            </div>
        `;
        
        const circle = $('reflexCircle');
        const text = $('reflexText');
        const hint = $('reflexHint');
        
        currentMinigame.state = 'waiting';
        
        // AUTO-START apr√®s 2 secondes
        setTimeout(() => {
            currentMinigame.state = 'red';
            circle.style.background = '#ef4444';
            circle.style.borderColor = '#ef4444';
            text.textContent = "Attends le VERT...";
            hint.textContent = "Ne clique pas maintenant !";
            
            // D√©lai al√©atoire entre 2 et 5 secondes
            const delay = 2000 + Math.random() * 3000;
            
            currentMinigame.timeoutId = setTimeout(() => {
                if (currentMinigame.state === 'red') {
                    currentMinigame.state = 'green';
                    currentMinigame.startTime = Date.now();
                    circle.style.background = '#22c55e';
                    circle.style.borderColor = '#22c55e';
                    text.textContent = "CLIQUE MAINTENANT !";
                    hint.textContent = "";
                }
            }, delay);
        }, 2000);
        
        // Gestionnaire de clic
        circle.addEventListener('click', handleReflexClick);
    }

    function handleReflexClick() {
        const circle = $('reflexCircle');
        const text = $('reflexText');
        const hint = $('reflexHint');
        
        if (currentMinigame.state === 'red') {
            // TROP T√îT !
            clearTimeout(currentMinigame.timeoutId);
            currentMinigame.clickedBeforeGreen = true;
            currentMinigame.state = 'failed';
            
            circle.style.background = '#7f1d1d';
            circle.style.borderColor = 'var(--danger)';
            text.textContent = "‚ùå Trop t√¥t ! Tu as cliqu√© avant le vert !";
            hint.textContent = "R√©essaye au prochain round...";
            hint.style.color = 'var(--danger)';
            
            // Shake animation
            circle.style.animation = 'shake 0.5s';
            
            setTimeout(() => {
                endPlayerTurnDirectly();
            }, 2000);
            
        } else if (currentMinigame.state === 'green') {
            // CLIC VALIDE
            const time = Date.now() - currentMinigame.startTime;
            currentMinigame.reactionTime = time;
            currentMinigame.state = 'done';
            
            circle.removeEventListener('click', handleReflexClick);
            
            if (time > 800) {
                // TROP LENT
                circle.style.background = '#b45309';
                circle.style.borderColor = 'var(--warning)';
                text.textContent = `‚è±Ô∏è ${time}ms - Trop lent !`;
                hint.textContent = "Il fallait moins de 800ms...";
                hint.style.color = 'var(--warning)';
                
                setTimeout(() => {
                    endPlayerTurnDirectly();
                }, 2000);
                
            } else {
                // R√âUSSI !
                circle.style.background = '#16a34a';
                circle.style.borderColor = 'var(--success)';
                text.textContent = `‚úÖ ${time}ms - Excellent !`;
                
                if (time < 200) {
                    hint.textContent = "‚ö° R√©flexes surhumains !";
                } else if (time < 400) {
                    hint.textContent = "üéØ Tr√®s rapide !";
                } else {
                    hint.textContent = "üëç Bien jou√© !";
                }
                hint.style.color = 'var(--success)';
                
                // Particules de succ√®s
                createSimpleConfetti();
                
                setTimeout(rewardClue, 1500);
            }
        }
    }

    // Mini-jeu 3 : Code couleur (retenir une courte s√©quence)
    function generateColorCodeGame() {
        const symbols = ['üî¥', 'üü¢', 'üîµ', 'üü°'];
        const length = 4;
        const sequence = [];
        for (let i = 0; i < length; i++) {
            sequence.push(symbols[Math.floor(Math.random() * symbols.length)]);
        }
        return {
            type: 'colorcode',
            sequence,
            userInput: [],
            step: 'show' // show -> input -> done
        };
    }
    function renderColorCodeGame() {
        currentMinigame = generateColorCodeGame();
        const container = $('minigameContent');
        
        // NOUVEAU : Instructions d'abord
        container.innerHTML = `
            <div style="text-align:center;padding:20px;">
                <div style="font-size:3rem;margin-bottom:12px;">üé®</div>
                <h3 style="margin:0 0 8px 0;font-size:1.1rem;">Code Couleur</h3>
                <p style="margin:0 0 12px 0;font-size:0.85rem;color:var(--text-muted);">
                    M√©morise la s√©quence puis reproduis-la
                </p>
                <div style="background:var(--accent-soft);border:1px solid var(--accent);border-radius:12px;padding:10px;margin-bottom:16px;">
                    <p style="margin:0;font-size:0.8rem;color:var(--accent);">
                        <strong>üéØ Pour gagner :</strong> Retrouve l'ordre exact des 4 symboles
                    </p>
                    <p style="margin:6px 0 0 0;font-size:0.75rem;">
                        Tu auras 5 secondes pour m√©moriser !
                    </p>
                </div>
                <button class="btn btn-primary btn-full" id="btnStartColorCode">
                    C'est parti ! üöÄ
                </button>
            </div>
        `;
        
        $('btnStartColorCode').addEventListener('click', () => {
            startColorCodeGameActual();
        });
    }

    function startColorCodeGameActual() {
        const container = $('minigameContent');
        
        // Afficher la s√©quence avec countdown
        container.innerHTML = `
            <p style="font-size:0.8rem;margin-bottom:8px;text-align:center;color:var(--accent);">
                <strong>M√©morise cette s√©quence :</strong>
            </p>
            <div id="codeSequence" style="font-size:2rem;text-align:center;margin-bottom:12px;padding:20px;background:var(--accent-soft);border-radius:12px;border:2px solid var(--accent);">
                ${currentMinigame.sequence.join(' ')}
            </div>
            <p id="countdownText" style="text-align:center;color:var(--accent);font-size:1.4rem;font-weight:700;margin:0;">
                <span id="countdown">5</span>s
            </p>
            <div id="codeInput" style="display:none;">
                <div id="codeButtons" style="display:flex;gap:8px;justify-content:center;margin-bottom:12px;margin-top:16px;">
                    ${['üî¥','üü¢','üîµ','üü°'].map(sym => `
                        <button class="btn btn-ghost code-btn" data-sym="${sym}" style="padding:12px 16px;font-size:1.5rem;">${sym}</button>
                    `).join('')}
                </div>
                <div style="text-align:center;font-size:1rem;margin-bottom:12px;">
                    Ta r√©ponse : <span id="codeInputDisplay" style="font-size:1.3rem;color:var(--accent);">_ _ _ _</span>
                </div>
                <p id="codeStatus" style="text-align:center;font-size:0.8rem;color:var(--text-muted);">
                    Clique sur les symboles dans le bon ordre
                </p>
            </div>
        `;
        
        // Compte √† rebours de 5 secondes
        let timeLeft = 5;
        const countdownInterval = setInterval(() => {
            timeLeft--;
            const countdownEl = $('countdown');
            if (countdownEl) {
                countdownEl.textContent = timeLeft;
                
                // Effet visuel sur les derni√®res secondes
                if (timeLeft <= 2) {
                    $('countdownText').style.color = 'var(--danger)';
                    $('countdownText').style.animation = 'pulse 0.5s infinite';
                }
            }
            
            if (timeLeft <= 0) {
                clearInterval(countdownInterval);
                hideSequenceAndShowInput();
            }
        }, 1000);
    }

    function hideSequenceAndShowInput() {
        const seqDiv = $('codeSequence');
        const countdownDiv = $('countdownText');
        const inputDiv = $('codeInput');
        
        if (seqDiv) {
            seqDiv.style.display = 'none';
        }
        if (countdownDiv) {
            countdownDiv.style.display = 'none';
        }
        if (inputDiv) {
            inputDiv.style.display = 'block';
            inputDiv.style.animation = 'fadeInUp 0.3s';
        }
        
        // Attacher les listeners
        document.querySelectorAll('.code-btn').forEach(btn => {
            btn.addEventListener('click', handleColorCodeClick);
        });
    }

    function handleColorCodeClick(e) {
        if (currentMinigame.step === 'done') return;
        
        const sym = e.target.dataset.sym;
        currentMinigame.userInput.push(sym);
        
        // Mise √† jour affichage
        const filled = currentMinigame.userInput.concat(
            Array(4 - currentMinigame.userInput.length).fill('_')
        );
        $('codeInputDisplay').textContent = filled.join(' ');
        
        // Effet visuel sur le bouton cliqu√©
        e.target.style.transform = 'scale(0.9)';
        setTimeout(() => {
            e.target.style.transform = 'scale(1)';
        }, 100);
        
        if (currentMinigame.userInput.length === 4) {
            // V√©rification
            const ok = currentMinigame.userInput.every(
                (s, i) => s === currentMinigame.sequence[i]
            );
            currentMinigame.step = 'done';
            
            const status = $('codeStatus');
            if (ok) {
                status.textContent = "‚úÖ Parfait ! Indice gagn√© !";
                status.style.color = 'var(--success)';
                status.style.fontSize = '1rem';
                status.style.fontWeight = '600';
                
                createSimpleConfetti();
                
                setTimeout(rewardClue, 1500);
            } else {
                status.textContent = "‚ùå Incorrect. R√©essaye !";
                status.style.color = 'var(--danger)';
                
                setTimeout(() => {
                    currentMinigame.userInput = [];
                    currentMinigame.step = 'input';
                    $('codeInputDisplay').textContent = '_ _ _ _';
                    status.textContent = 'Clique sur les symboles dans le bon ordre';
                    status.style.color = 'var(--text-muted)';
                    status.style.fontSize = '0.8rem';
                    status.style.fontWeight = '400';
                }, 1500);
            }
        }
    }
    // Mini-jeu 4 : Puzzle
    function generatePuzzleGame() {
        const pieces = ['‚ë†', '‚ë°', '‚ë¢', '‚ë£', '‚ë§', '‚ë•'];
        shuffleArray(pieces);
        const correct = ['‚ë†', '‚ë°', '‚ë¢', '‚ë£', '‚ë§', '‚ë•']; // Ordre attendu
        
        return {
            type: 'puzzle',
            pieces: pieces.map((p, idx) => ({id: idx, icon: p, position: idx})),
            correctOrder: correct,
            moves: 0,
            selected: null
        };
    }

    function updatePassScreen() {
        const idx = state.currentRevealIndex;
        const player = state.players[idx];
        $("passPlayerName").textContent = player.name;
    }

    function renderPlayerView() {
        const idx = state.currentRevealIndex;
        const player = state.players[idx];
        const isHitman = player.role === "hitman";

        $("playerViewTitle").textContent = player.name;
        $("playerViewSubtitle").textContent = isHitman
            ? "Ton r√¥le : Tueur sous contrat"
            : "Ton r√¥le : Civil";

        const pillContainer = $("rolePill");
        pillContainer.innerHTML = "";
        const pill = document.createElement("div");
        pill.classList.add("pill");
        if (isHitman) {
            pill.classList.add("pill-hitman");
            pill.textContent = "Tueur";
        } else {
            pill.classList.add("pill-civil");
            pill.textContent = "Civil";
        }
        pillContainer.appendChild(pill);

        const container = $("playerViewContent");
        container.innerHTML = "";

        const profileCard = document.createElement("div");
        profileCard.className = "profile-card";

        const profileTitle = document.createElement("div");
        // MODIFICATION ICI
        profileTitle.textContent = isHitman
            ? "üìã Ton identit√© (√† cacher aux autres !)"  // CHANG√â
            : "Ton profil secret";

        const list = document.createElement("ul");
        list.className = "profile-list";

        if (isHitman) {
            const target = state.players[state.targetIndex];
            const targetProfile = target.profile;
            const attrs = state.contractAttributes;

            // NOUVEAU : Afficher SON profil d'abord
            const liProfile = document.createElement("li");
            liProfile.innerHTML = `<strong>Ton profil (√† m√©moriser) :</strong><br>
                ‚Ä¢ Genre : ${player.profile.gender}<br>
                ‚Ä¢ Accessoire : ${player.profile.accessory}<br>
                ‚Ä¢ M√©tier : ${player.profile.job}<br>
                ‚Ä¢ Caract√®re : ${player.profile.trait}`;
            list.appendChild(liProfile);

            const liSpacer = document.createElement("li");
            liSpacer.innerHTML = "<hr style='border:none;border-top:1px solid rgba(148,163,184,0.2);margin:8px 0;'>";
            list.appendChild(liSpacer);

            const liIntro = document.createElement("li");
            liIntro.innerHTML = "<strong>Ta mission :</strong> √âliminer une cible parmi les autres joueurs.";
            list.appendChild(liIntro);

            const liHint = document.createElement("li");
            const parts = [];
            attrs.forEach((key) => {
                let label;
                let val;
                switch (key) {
                    case "gender":
                        label = "Genre";
                        val = targetProfile.gender;
                        break;
                    case "accessory":
                        label = "Accessoire";
                        val = targetProfile.accessory;
                        break;
                    case "job":
                        label = "M√©tier";
                        val = targetProfile.job;
                        break;
                    case "trait":
                        label = "Caract√®re";
                        val = targetProfile.trait;
                        break;
                }
                parts.push(label + " : " + val);
            });
            liHint.innerHTML =
                "Ta cible correspond √† : <span class=\"contract-highlight\">" +
                parts.join(" ‚Ä¢ ") +
                "</span>.";
            list.appendChild(liHint);

            const liWarning = document.createElement("li");
            liWarning.innerHTML = "<strong>‚ö†Ô∏è ATTENTION :</strong> Si tu √©limines la mauvaise personne, un de TES attributs sera r√©v√©l√© aux civils !";
            list.appendChild(liWarning);

            const tagline = document.createElement("div");
            tagline.className = "contract-tagline";
            tagline.textContent =
                "Reste discret, ne r√©v√®le jamais ton r√¥le, et d√©duis qui est ta cible en observant les autres.";
            profileCard.appendChild(profileTitle);
            profileCard.appendChild(list);
            profileCard.appendChild(tagline);
        } else {
            const profile = player.profile;

            const li1 = document.createElement("li");
            li1.textContent = "Genre : " + profile.gender;
            const li2 = document.createElement("li");
            li2.textContent = "Accessoire : " + profile.accessory;
            const li3 = document.createElement("li");
            li3.textContent = "M√©tier : " + profile.job;
            const li4 = document.createElement("li");
            li4.textContent = "Caract√®re : " + profile.trait;

            list.appendChild(li1);
            list.appendChild(li2);
            list.appendChild(li3);
            list.appendChild(li4);

            profileCard.appendChild(profileTitle);
            profileCard.appendChild(list);

            const tagline = document.createElement("div");
            tagline.className = "contract-tagline";
            tagline.textContent =
                "Ton but : rep√©rer le tueur en observant les comportements et en recoupant les profils. Utilise le syst√®me de t√©moins pour interroger les autres !";
            profileCard.appendChild(tagline);
        }

        container.appendChild(profileCard);
    }

    function updateSummary() {
        const badgesContainer = $("summaryBadges");
        badgesContainer.innerHTML = "";

        const badgePlayers = document.createElement("div");
        badgePlayers.className = "summary-badge";
        badgePlayers.textContent = state.players.length + " joueurs";
        badgesContainer.appendChild(badgePlayers);

        const badgeHitman = document.createElement("div");
        badgeHitman.className = "summary-badge";
        badgeHitman.textContent = "1 tueur, " + (state.players.length - 1) + " civils";
        badgesContainer.appendChild(badgeHitman);

        const badgeContract = document.createElement("div");
        badgeContract.className = "summary-badge";
        badgeContract.textContent = "Contrat avec " + state.contractAttributes.length + " attributs";
        badgesContainer.appendChild(badgeContract);
    }

    // ========== GESTION DES √âCRANS ==========
    
    function startInvestigationPhase() {
        state.currentRound++;
        state.currentPlayerTurn = 0;
        state.hitmanAttempted = false;
        
        // Cr√©er ordre al√©atoire pour ce round (seulement joueurs vivants)
        state.investigationOrder = state.players
            .map((p, idx) => idx)
            .filter(idx => !state.eliminatedPlayers.includes(idx));
        shuffleArray(state.investigationOrder);
        
        updateInvestigationScreen();
        showScreen('screen-investigation');
    }
    
    function updateInvestigationScreen() {
        $('roundNumber').textContent = state.currentRound;
        const playerIdx = state.investigationOrder[state.currentPlayerTurn];
        const player = state.players[playerIdx];
        $('investigationPlayerName').textContent = player.name;
    }
    
    function showPlayerTurn() {
        const playerIdx = state.investigationOrder[state.currentPlayerTurn];
        const player = state.players[playerIdx];
        const isHitman = player.role === 'hitman';
        const witnessDiv = $('witnessAction');
        const alreadyUsed = !!state.witnessUses[playerIdx];
        if (!isHitman && !alreadyUsed) {
            witnessDiv.style.display = 'block';
        } else {
            witnessDiv.style.display = 'none';
        }


        $('turnPlayerTitle').textContent = player.name;

        // Profil du joueur
        const profileDiv = $('turnPlayerProfile');
        profileDiv.innerHTML = `
            <div class="profile-title">Ton profil (${isHitman ? 'HITMAN' : 'Civil'})</div>
            <ul class="profile-list">
                <li>Genre : ${player.profile.gender}</li>
                <li>Accessoire : ${player.profile.accessory}</li>
                <li>M√©tier : ${player.profile.job}</li>
                <li>Caract√®re : ${player.profile.trait}</li>
            </ul>
            ${isHitman ? `<p style="font-size:0.8rem;color:var(--hitman);margin-top:6px;">
                <strong>Contrat :</strong>
                ${state.contractAttributes.map(attr => {
                    const target = state.players[state.targetIndex];
                    let val = attr === 'gender' ? target.profile.gender :
                            attr === 'accessory' ? target.profile.accessory :
                            attr === 'job' ? target.profile.job : target.profile.trait;
                    let label = attr === 'gender' ? 'Genre' :
                            attr === 'accessory' ? 'Accessoire' :
                            attr === 'job' ? 'M√©tier' : 'Caract√®re';
                    return `${label} = ${val}`;
                }).join(' + ')}
            </p>` : ''}
        `;

        // Afficher les indices d√©j√† gagn√©s par ce joueur
        renderPlayerCluesFor(playerIdx);

        // Pr√©parer le mini‚Äëjeu
        $('minigameContainer').style.display = 'block';
        $('clueReveal').style.display = 'none';
        $('btnEndTurn').style.display = 'none';
        $('btnBackToInvestigation').style.display = 'none';
        setBackgroundMood('default');   // repasse le fond au bleu
        startTurnTimer();              // d√©marre les 60 s du tour

        // Choix du mini‚Äëjeu
        const r = Math.random();
        let minigameType;
        if (r < 0.34) minigameType = 'memory';
        else if (r < 0.67) minigameType = 'reflex';
        else minigameType = 'colorcode';

        renderMinigame(minigameType);
        startTurnTimer();

        // Zone Hitman
        const hitmanDiv = $('hitmanAction');
        if (isHitman && !state.hitmanAttempted) {
            hitmanDiv.style.display = 'block';
            const select = $('hitmanTargetSelect');
            select.innerHTML = '<option value="">-- Choisir une cible --</option>';
            state.players.forEach((p, idx) => {
                if (idx !== playerIdx && !state.eliminatedPlayers.includes(idx)) {
                    const opt = document.createElement('option');
                    opt.value = idx;
                    opt.textContent = p.name;
                    select.appendChild(opt);
                }
            });
        } else {
            hitmanDiv.style.display = 'none';
        }

        showScreen('screen-player-turn');
    }
    
    let currentMinigame = null;
    
    function renderMinigame(type) {
        const container = $('minigameContent');
        
        if (type === 'memory') {
            showMinigameInstructions('memory', () => {
                renderMemoryGameActual();
            });
        } else if (type === 'reflex') {
            currentMinigame = {
            type: 'reflex',
            state: 'waiting', // waiting -> green -> done
            startTime: 0
        };

        const container = $('minigameContent');
        container.innerHTML = `
            <div id="reflexArea" style="padding:20px;text-align:center;border:2px dashed rgba(148,163,184,0.3);border-radius:12px;cursor:pointer;background:rgba(15,23,42,0.5);">
                <p id="reflexText" style="font-size:0.9rem;margin:0 0 8px 0;">
                    Clique sur la zone quand le cercle devient VERT.
                </p>
                <div id="reflexCircle" style="width:70px;height:70px;border-radius:50%;background:#334155;margin:10px auto;transition:background 0.12s;"></div>
            </div>
            <p id="reflexResult" style="text-align:center;margin-top:8px;font-size:0.8rem;color:var(--text-muted);">
                Pr√©pare-toi...
            </p>
        `;

        const area = $('reflexArea');
        const circle = $('reflexCircle');
        const text = $('reflexText');
        const result = $('reflexResult');

        // D√©marrer la s√©quence automatiquement
        setTimeout(() => {
            if (!currentMinigame || currentMinigame.type !== 'reflex') return;
            currentMinigame.state = 'armed';
            circle.style.background = '#ef4444'; // rouge
            text.textContent = 'Attends le vert...';

            const delay = 1500 + Math.random() * 2500; // 1.5‚Äì4 sec

            setTimeout(() => {
                if (!currentMinigame || currentMinigame.type !== 'reflex' || currentMinigame.state !== 'armed') return;
                currentMinigame.state = 'green';
                currentMinigame.startTime = Date.now();
                circle.style.background = '#22c55e'; // vert
                text.textContent = 'CLIQUE !';
            }, delay);
        }, 800);

        area.addEventListener('click', () => {
            if (!currentMinigame || currentMinigame.type !== 'reflex' || currentMinigame.state === 'done') return;

            // Clic trop t√¥t
            if (currentMinigame.state === 'armed') {
                currentMinigame.state = 'done';
                result.textContent = 'Trop t√¥t ! Pas d‚Äôindice pour ce tour.';
                result.style.color = 'var(--danger)';
                setBackgroundMood('fail'); // fond rouge
                stopTurnTimer();
                setTimeout(() => {
                    $('minigameContainer').style.display = 'none';
                    $('clueReveal').style.display = 'block';
                    $('clueText').innerHTML = `
                        <strong style="color:var(--danger);">‚è± Rat√©</strong><br>
                        Tu as cliqu√© avant le vert, aucun indice gagn√©.
                    `;
                    $('btnEndTurn').style.display = 'inline-flex';
                }, 800);
                return;
            }

            // Clic sur le vert
            if (currentMinigame.state === 'green') {
                currentMinigame.state = 'done';
                const time = Date.now() - currentMinigame.startTime;
                if (time > 800) {
                    // Trop lent = pas d‚Äôindice
                    result.textContent = `Trop lent (${time} ms). Pas d‚Äôindice pour ce tour.`;
                    result.style.color = 'var(--danger)';
                    setBackgroundMood('fail'); // fond rouge
                    stopTurnTimer();
                    setTimeout(() => {
                        $('minigameContainer').style.display = 'none';
                        $('clueReveal').style.display = 'block';
                        $('clueText').innerHTML = `
                            <strong style="color:var(--danger);">‚è± Trop lent</strong><br>
                            Temps : ${time} ms. Aucun indice gagn√©.
                        `;
                        $('btnEndTurn').style.display = 'inline-flex';
                    }, 900);
                } else {
                    // Succ√®s = indice
                    result.textContent = `Bravo ! Temps : ${time} ms. Indice gagn√©.`;
                    result.style.color = 'var(--accent)';
                    setTimeout(rewardClue, 800);
                }
            }
        });
        } else if (type === 'colorcode') {
            renderColorCodeGame(); // D√©j√† modifi√© ci-dessus
        } else if (type === 'puzzle') {
            showMinigameInstructions('puzzle', () => {
                renderPuzzleGameActual();
            });
        }
    }

    function renderMemoryGameActual() {
        currentMinigame = generateMemoryGame();
        const container = $('minigameContent');
        
        container.innerHTML = `
            <p style="font-size:0.8rem;margin-bottom:8px;text-align:center;">Trouve les paires ! (<span id="memoryMatches">0</span>/6)</p>
            <div id="memoryGrid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;max-width:280px;margin:0 auto;">
                ${currentMinigame.cards.map((card, idx) => `
                    <button class="memory-card" data-idx="${idx}" style="aspect-ratio:1;border:2px solid rgba(148,163,184,0.3);border-radius:8px;background:rgba(15,23,42,0.8);font-size:1.8rem;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.3s;">
                        ${card.revealed || card.matched ? card.icon : '‚ùì'}
                    </button>
                `).join('')}
            </div>
            <p id="memoryStatus" style="text-align:center;margin-top:8px;font-size:0.8rem;color:var(--accent);">Clique sur 2 cartes</p>
        `;
        
        container.querySelectorAll('.memory-card').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const idx = parseInt(e.target.dataset.idx);
                handleMemoryCardClick(idx);
            });
        });
    }

    function renderPuzzleGameActual() {
        currentMinigame = generatePuzzleGame();
        const container = $('minigameContent');
        
        container.innerHTML = `
            <p style="font-size:0.8rem;margin-bottom:8px;text-align:center;">
                Range du plus petit au plus grand ! (<span id="puzzleMoves">0</span> coups)
            </p>
            <div id="puzzleGrid" style="display:flex;gap:8px;justify-content:center;margin-bottom:12px;flex-wrap:wrap;">
                ${currentMinigame.pieces.map((piece, idx) => `
                    <button class="btn btn-ghost puzzle-piece" data-idx="${idx}" style="font-size:2rem;padding:16px;min-width:60px;">
                        ${piece.icon}
                    </button>
                `).join('')}
            </div>
            <p id="puzzleStatus" style="text-align:center;font-size:0.8rem;color:var(--text-muted);">
                Clique sur 2 pi√®ces pour les √©changer
            </p>
        `;

        let selectedPiece = null;
        const handlePuzzleClick = function() {
            const idx = parseInt(this.dataset.idx);
            
            if (selectedPiece === null) {
                selectedPiece = idx;
                this.style.background = 'var(--accent-soft)';
                this.style.borderColor = 'var(--accent)';
                this.style.transform = 'scale(1.1)';
            } else {
                if (selectedPiece === idx) {
                    // M√™me pi√®ce = d√©s√©lection
                    this.style.background = '';
                    this.style.borderColor = '';
                    this.style.transform = 'scale(1)';
                    selectedPiece = null;
                    return;
                }
                
                // √âchanger
                const temp = currentMinigame.pieces[selectedPiece];
                currentMinigame.pieces[selectedPiece] = currentMinigame.pieces[idx];
                currentMinigame.pieces[idx] = temp;
                currentMinigame.moves++;
                
                // Update moves counter
                $('puzzleMoves').textContent = currentMinigame.moves;
                
                // Rerender
                const grid = $('puzzleGrid');
                grid.innerHTML = currentMinigame.pieces.map((piece, i) => `
                    <button class="btn btn-ghost puzzle-piece" data-idx="${i}" style="font-size:2rem;padding:16px;min-width:60px;">
                        ${piece.icon}
                    </button>
                `).join('');
                
                // Re-attach listeners
                selectedPiece = null;
                grid.querySelectorAll('.puzzle-piece').forEach(b => {
                    b.addEventListener('click', handlePuzzleClick);
                });
                
                // V√©rifier si r√©solu
                const current = currentMinigame.pieces.map(p => p.icon);
                const isSolved = current.every((icon, i) => icon === currentMinigame.correctOrder[i]);
                
                if (isSolved) {
                    $('puzzleStatus').textContent = `‚úÖ R√©solu en ${currentMinigame.moves} coups ! Indice gagn√© !`;
                    $('puzzleStatus').style.color = 'var(--success)';
                    $('puzzleStatus').style.fontSize = '1rem';
                    $('puzzleStatus').style.fontWeight = '600';
                    
                    createSimpleConfetti();
                    
                    // D√©sactiver tous les boutons
                    grid.querySelectorAll('.puzzle-piece').forEach(b => {
                        b.style.pointerEvents = 'none';
                        b.style.opacity = '0.7';
                    });
                    
                    setTimeout(rewardClue, 1500);
                }
            }
        };
        
        container.querySelectorAll('.puzzle-piece').forEach(btn => {
            btn.addEventListener('click', handlePuzzleClick);
        });
    }
    
    function startTurnTimer() {
        // Toujours nettoyer l'ancien timer avant d'en lancer un nouveau
        stopTurnTimer();

        state.turnTimeLeft = 60;
        state.clueGivenThisTurn = false;

        const timer = $('turnTimer');
        const value = $('turnTimerValue');
        if (!timer || !value) return; // s√©curit√©

        timer.style.display = 'flex';
        timer.classList.remove('urgent');
        value.textContent = state.turnTimeLeft;

        state.turnTimerId = setInterval(() => {
            state.turnTimeLeft--;
            value.textContent = state.turnTimeLeft;

            if (state.turnTimeLeft <= 10) {
                timer.classList.add('urgent');
            }

            if (state.turnTimeLeft <= 0) {
                // Temps √©coul√© UNE SEULE fois
                stopTurnTimer();

                if (!state.clueGivenThisTurn) {
                    setBackgroundMood('fail'); // fond rouge

                    // Fin du mini-jeu sans indice
                    const clueDiv = $('clueReveal');
                    if (clueDiv) {
                        $('minigameContainer').style.display = 'none';
                        clueDiv.style.display = 'block';
                        $('clueText').innerHTML = `
                            <strong style="color:var(--danger);">‚è± Temps √©coul√©</strong><br>
                            Tu n'as pas gagn√© d'indice pour ce tour.
                        `;
                        $('btnEndTurn').style.display = 'inline-flex';
                    }
                }
            }
        }, 1000);
    }

    function stopTurnTimer() {
        const timer = $('turnTimer');
        if (state.turnTimerId) {
            clearInterval(state.turnTimerId);
            state.turnTimerId = null;
        }
        if (timer) {
            timer.style.display = 'none';
            timer.classList.remove('urgent');
        }
    }
    
    function handleMemoryCardClick(idx) {
        const card = currentMinigame.cards[idx];
        if (card.revealed || card.matched || currentMinigame.selected.length >= 2) return;
        
        card.revealed = true;
        currentMinigame.selected.push(idx);
        
        // Update UI
        const btn = document.querySelector(`.memory-card[data-idx="${idx}"]`);
        btn.textContent = card.icon;
        
        if (currentMinigame.selected.length === 2) {
            const [idx1, idx2] = currentMinigame.selected;
            const card1 = currentMinigame.cards[idx1];
            const card2 = currentMinigame.cards[idx2];
            
            if (card1.icon === card2.icon) {
                // Match !
                card1.matched = true;
                card2.matched = true;
                currentMinigame.matches++;
                currentMinigame.selected = [];
                $('memoryStatus').textContent = `Paires trouv√©es : ${currentMinigame.matches}/6`;
                
                if (currentMinigame.matches === 6) {
                    $('memoryStatus').textContent = "Bravo ! Indice gagn√© !";
                    $('memoryStatus').style.color = 'var(--accent)';
                    setTimeout(rewardClue, 800);
                }
            } else {
                // Pas match
                setTimeout(() => {
                    card1.revealed = false;
                    card2.revealed = false;
                    document.querySelector(`.memory-card[data-idx="${idx1}"]`).textContent = '?';
                    document.querySelector(`.memory-card[data-idx="${idx2}"]`).textContent = '?';
                    currentMinigame.selected = [];
                }, 800);
            }
        }
    }
    
    function rewardClue() {
        const playerIdx = state.investigationOrder[state.currentPlayerTurn];
        const clue = generateClue(playerIdx);

        state.clueGivenThisTurn = true;
        stopTurnTimer();
        setBackgroundMood('success');

        if (clue) {
            const entry = {
                round: state.currentRound,
                player: state.players[playerIdx].name,
                ...clue,
                public: false // par d√©faut PRIV√â
            };
            state.journal.push(entry);
            state.lastClueIndex = state.journal.length - 1;

            // 1) On remplit le texte de l‚Äôindice
            $('clueText').innerHTML = `
                <strong>${clue.isFalse ? '‚ö†Ô∏è INDICE (peut-√™tre faux)' : '‚úÖ INDICE V√âRIFI√â'}</strong><br>
                ${clue.targetPlayer} : ${clue.attribute} = ${clue.value}
            `;

            // 2) Puis on rend visibles la carte + les boutons + le bouton fin de tour
            $('clueReveal').style.display = 'block';
            $('clueActionsRow').style.display = 'flex';
            $('btnEndTurn').style.display = 'inline-flex';
        }

        $('minigameContainer').style.display = 'none';
        $('btnEndTurn').style.display = 'inline-flex';
        $('clueActionsRow').style.display = 'flex'; // si tu as ajout√© la ligne de boutons R√©v√©ler / Garder
    }

    
    function endPlayerTurn() {
        stopTurnTimer();
        setBackgroundMood('default'); // retour au bleu
        
        state.currentPlayerTurn++;
        
        if (state.currentPlayerTurn >= state.investigationOrder.length) {
            // Fin du round, aller au journal puis vote
            updateJournal();
            showScreen('screen-journal');
        } else {
            // Joueur suivant
            updateInvestigationScreen();
            setBackgroundMood('default');
            showScreen('screen-investigation');
        }
    }
    
    function updateJournal() {
        renderJournalList();
        renderDeductionTable();
    }

    function renderJournalList() {
        const container = $('journalEntries');
        
        
        if (state.journal.length === 0) {
            container.innerHTML = '<p class="hint" style="text-align: center; padding: 20px;">Aucun indice pour le moment...</p>';
            return;
        }
        
        // Appliquer le filtre
        let filteredJournal = state.journal.filter(e => e.public);
        if (state.currentJournalFilter !== 'all') {
            filteredJournal = state.journal.filter(j => {
                const attrKey = j.attributeKey || 
                            (j.attribute === 'Genre' ? 'gender' :
                            j.attribute === 'Accessoire' ? 'accessory' :
                            j.attribute === 'M√©tier' ? 'job' : 'trait');
                return attrKey === state.currentJournalFilter;
            });
        }
        
        container.innerHTML = filteredJournal.map((entry, idx) => {
            const reliabilityIcon = entry.reliability === 'verified' ? '‚úì' :
                                entry.reliability === 'claimed' ? '‚ö†' : '‚úó';
            const reliabilityClass = entry.reliability === 'verified' ? 'reliability-verified' :
                                entry.reliability === 'claimed' ? 'reliability-claimed' : 'reliability-suspicious';
            
            let description = '';
            if (entry.type === 'penalty' || entry.isPenalty) {
                description = `üö® <strong>P√âNALIT√â</strong> : ${entry.attribute} du Hitman r√©v√©l√© = ${entry.value}`;
            } else if (entry.type === 'witness') {
                description = `üó£Ô∏è <strong>${entry.player}</strong> a interrog√© <strong>${entry.targetPlayer}</strong> : ${entry.attribute} = ${entry.value}`;
            } else if (entry.type === 'fake_planted') {
                description = `üé≠ Un indice suspect a √©t√© plant√© : <strong>${entry.targetPlayer}</strong> - ${entry.attribute} = ${entry.value}`;
            } else {
                description = `<strong>${entry.player}</strong> d√©couvre : <strong>${entry.targetPlayer}</strong> - ${entry.attribute} = ${entry.value}`;
            }
            
            return `
                <div class="clue-card">
                    <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;">
                        <span style="font-size:0.7rem;color:var(--text-muted);">Round ${entry.round}</span>
                        <span class="${reliabilityClass}" style="font-size:0.9rem;">${reliabilityIcon}</span>
                    </div>
                    <div style="font-size:0.85rem;">${description}</div>
                </div>
            `;
        }).join('');
    }

    function renderDeductionTable() {
        const grid = $('deductionGrid');
        
        // En-t√™tes
        const headers = ['Joueur', 'Genre', 'Accessoire', 'M√©tier', 'Caract√®re'];
        
        // Cr√©er une matrice de donn√©es
        const deductionData = {};
        state.players.forEach(p => {
            if (!state.eliminatedPlayers.includes(p.id)) {
                deductionData[p.id] = {
                    name: p.name,
                    gender: {},
                    accessory: {},
                    job: {},
                    trait: {}
                };
            }
        });
        
        // Remplir avec les indices du journal
        state.journal.forEach(entry => {
            if (!deductionData[entry.targetIndex]) return;
            
            const attrKey = entry.attributeKey || 
                        (entry.attribute === 'Genre' ? 'gender' :
                        entry.attribute === 'Accessoire' ? 'accessory' :
                        entry.attribute === 'M√©tier' ? 'job' : 'trait');
            
            if (!deductionData[entry.targetIndex][attrKey][entry.value]) {
                deductionData[entry.targetIndex][attrKey][entry.value] = {
                    count: 0,
                    reliability: entry.reliability
                };
            }
            deductionData[entry.targetIndex][attrKey][entry.value].count++;
        });
        
        let html = '';
        
        // En-t√™tes
        headers.forEach((h, idx) => {
            html += `<div class="deduction-cell deduction-header ${idx === 0 ? 'deduction-player' : ''}">${h}</div>`;
        });
        
        // Lignes joueurs
        Object.values(deductionData).forEach(player => {
            html += `<div class="deduction-cell deduction-player">${player.name}</div>`;
            
            ['gender', 'accessory', 'job', 'trait'].forEach(attr => {
                const values = Object.entries(player[attr]);
                if (values.length === 0) {
                    html += `<div class="deduction-cell">?</div>`;
                } else if (values.length === 1) {
                    const [val, data] = values[0];
                    const icon = data.reliability === 'verified' ? '‚úì' :
                            data.reliability === 'claimed' ? '‚ö†' : '‚úó';
                    const colorClass = data.reliability === 'verified' ? 'reliability-verified' :
                                    data.reliability === 'claimed' ? 'reliability-claimed' : 'reliability-suspicious';
                    html += `<div class="deduction-cell"><span class="${colorClass}">${icon}</span> ${val}</div>`;
                } else {
                    // Plusieurs valeurs contradictoires
                    const summary = values.map(([val, data]) => {
                        const icon = data.reliability === 'verified' ? '‚úì' :
                                data.reliability === 'claimed' ? '‚ö†' : '‚úó';
                        return `${icon}${val}`;
                    }).join(' / ');
                    html += `<div class="deduction-cell" style="font-size:0.65rem;">${summary}</div>`;
                }
            });
        });
        
        grid.innerHTML = html;
    }

    
    function renderPlayerCluesFor(playerIdx) {
        const container = $('playerClues');
        const listDiv = $('playerCluesList');
        const playerName = state.players[playerIdx].name;

        const clues = state.journal.filter(e => e.player === playerName);

        if (clues.length === 0) {
            container.style.display = 'none';
            listDiv.innerHTML = '';
            return;
        }

        container.style.display = 'block';
        listDiv.innerHTML = clues.map(c => `
            <div class="clue-card">
                <div style="font-size:0.75rem;color:var(--text-muted);margin-bottom:2px;">
                    Round ${c.round}
                </div>
                <div>
                    <span style="color:${c.isFalse ? 'var(--danger)' : 'var(--accent)'};font-weight:600;">
                        ${c.targetPlayer}
                    </span> : ${c.attribute} = ${c.value}
                </div>
            </div>
        `).join('');
    }
    
    function startVotePhase() {
        const container = $('voteButtons');
        container.innerHTML = '';
        
        const alivePlayers = state.players.filter((p, idx) => !state.eliminatedPlayers.includes(idx));
        
        // R√©initialiser l'ordre de vote
        state.voteOrder = alivePlayers.map(p => p.id);
        state.currentVoter = 0;
        state.votes = {};
        
        // Afficher les boutons de vote pour le premier votant
        updateVoteButtons();
        
        $('voteConfirmation').style.display = 'none';
        $('btnRevealVotes').style.display = 'none';
        showScreen('screen-vote');
    }
    
    function updateVoteButtons() {
        const container = $('voteButtons');
        container.innerHTML = '';
        
        const alivePlayers = state.players.filter((p, idx) => !state.eliminatedPlayers.includes(idx));
        const currentVoterId = state.voteOrder[state.currentVoter];
        const currentVoter = state.players.find(p => p.id === currentVoterId);
        
        // Afficher le nom du votant actuel
        const title = document.createElement('div');
        title.style.cssText = 'margin-bottom:12px;font-size:0.9rem;color:var(--accent);font-weight:600;';
        title.textContent = `C'est au tour de ${currentVoter.name} de voter`;
        container.appendChild(title);
        
        // Cr√©er les boutons pour les autres joueurs (on ne peut pas voter pour soi)
        alivePlayers.forEach(player => {
            if (player.id === currentVoterId) return; // Ne pas afficher soi-m√™me
            
            const btn = document.createElement('button');
            btn.className = 'btn btn-ghost';
            btn.style.cssText = 'width:100%;text-align:left;justify-content:flex-start;margin-bottom:6px;';
            btn.innerHTML = `<span style="width:26px;height:26px;border-radius:50%;background:var(--accent-soft);display:flex;align-items:center;justify-content:center;margin-right:8px;font-size:0.8rem;">${player.name.charAt(0)}</span> ${player.name}`;
            btn.addEventListener('click', () => castVote(player.id));
            container.appendChild(btn);
        });
    }
    
    function castVote(targetId) {
        const currentVoterId = state.voteOrder[state.currentVoter];
        const voter = state.players.find(p => p.id === currentVoterId);
        state.votes[voter.id] = targetId;
        
        // Afficher confirmation
        $('voteConfirmation').style.display = 'block';
        $('votedPlayerName').textContent = state.players[targetId].name;
        
        // Passer au votant suivant ou r√©v√©ler
        state.currentVoter++;
        if (state.currentVoter >= state.voteOrder.length) {
            // Tous ont vot√©
            $('voteButtons').style.display = 'none';
            $('voteConfirmation').style.display = 'none';
            $('btnRevealVotes').style.display = 'inline-flex';
        } else {
            // Passer au votant suivant
            setTimeout(() => {
                $('voteConfirmation').style.display = 'none';
                updateVoteButtons();
            }, 1500);
        }
    }
    
    function revealVotes() {
        // Compter les votes
        const voteCounts = {};
        Object.values(state.votes).forEach(targetId => {
            voteCounts[targetId] = (voteCounts[targetId] || 0) + 1;
        });
        
        // Trouver le plus vot√©
        let maxVotes = 0;
        let eliminatedId = null;
        let tie = false;
        
        for (const [id, count] of Object.entries(voteCounts)) {
            if (count > maxVotes) {
                maxVotes = count;
                eliminatedId = parseInt(id);
                tie = false;
            } else if (count === maxVotes) {
                tie = true;
            }
        }
        
        // Afficher r√©sultats
        const container = $('voteResults');
        container.innerHTML = '<div style="margin-bottom:12px;"><strong>R√©sultats :</strong></div>';
        
        Object.entries(state.votes).forEach(([voterId, targetId]) => {
            const voter = state.players.find(p => p.id === parseInt(voterId));
            const target = state.players.find(p => p.id === targetId);
            container.innerHTML += `
                <div style="display:flex;justify-content:space-between;padding:6px 8px;background:rgba(15,23,42,0.5);border-radius:6px;margin-bottom:4px;font-size:0.85rem;">
                    <span>${voter.name}</span>
                    <span style="color:var(--accent);">‚Üí ${target.name}</span>
                </div>
            `;
        });
        
        // Gestion √©limination
        const elimDiv = $('eliminationReveal');
        const elimCard = $('eliminatedCard');
        
        if (tie || eliminatedId === null) {
            $('resolutionSubtitle').textContent = '√âgalit√© ! Personne n\'est √©limin√© ce round.';
            elimDiv.style.display = 'none';
        } else {
            const eliminated = state.players[eliminatedId];
            state.eliminatedPlayers.push(eliminatedId);

            const isHitman = eliminatedId === state.hitmanIndex;
            const isTarget = eliminatedId === state.targetIndex;

            $('resolutionSubtitle').textContent = `${eliminated.name} a √©t√© √©limin√© !`;
            elimDiv.style.display = 'block';

            elimCard.innerHTML = `
                <div class="profile-title" style="color:${isHitman ? 'var(--danger)' : 'var(--text)'};">
                    ${eliminated.name} √©tait ${isHitman ? 'le HITMAN !' : 'un CIVIL'}
                </div>
                <p style="font-size:0.85rem;margin:6px 0;">
                    ${
                        isHitman
                            ? 'Les civils ont vot√© juste !'
                            : isTarget
                                ? 'C\'√©tait la cible du Hitman...'
                                : 'Les civils ont fait une erreur.'
                    }
                </p>
                ${
                    !isHitman && !isTarget
                        ? `
                <div style="margin-top:8px;padding:8px;background:rgba(249,115,115,0.1);border-radius:6px;">
                    <p style="font-size:0.8rem;margin:0;color:var(--danger);">
                        ‚ö†Ô∏è Le Hitman peut continuer √† √©liminer des cibles !
                    </p>
                </div>`
                        : ''
                }
            `;

            // Marquer la victoire selon qui a √©t√© √©limin√©
            if (isHitman) {
                state.gameOver = true;
                state.winner = 'civils';
            } else if (isTarget) {
                state.hitmanSuccess = true;    // sa cible est √©limin√©e par vote
                state.gameOver = true;
                state.winner = 'hitman';
            }
        }

        showScreen('screen-resolution');

    }
    
    function nextRound() {
        // V√©rifier victoire
        if (checkVictoryConditions()) {
            showEndScreen();
            return;
        }
        
        // V√©rifier si Hitman a √©limin√© sa cible
        if (state.hitmanSuccess) {
            showEndScreen();
            return;
        }
        
        // Nouveau round
        state.voteOrder = null;
        state.currentVoter = 0;
        startInvestigationPhase();
    }
    
    function showEndScreen() {
        const hitman = state.players[state.hitmanIndex];
        const target = state.players[state.targetIndex];
        
        $('endTitle').textContent = state.winner === 'hitman' ? 'üèÜ Victoire du Hitman !' : '‚úÖ Victoire des Civils !';
        $('endSubtitle').textContent = state.winner === 'hitman' 
            ? 'Le tueur a r√©ussi √† √©liminer sa cible ou √† survivre jusqu\'au bout !'
            : 'Les civils ont identifi√© et √©limin√© le tueur !';
        
        const content = $('endContent');
        
        if (state.winner === 'hitman') {
            content.innerHTML = `
                <div class="profile-card" style="border-color:rgba(250,204,21,0.5);">
                    <div class="profile-title" style="color:var(--hitman);">Le Hitman</div>
                    <p style="font-size:0.9rem;"><strong>${hitman.name}</strong></p>
                    <p class="hint">Sa cible √©tait : ${target.name} (${target.profile.gender}, ${target.profile.job})</p>
                </div>
                <div style="margin-top:12px;padding:12px;background:rgba(15,23,42,0.8);border-radius:var(--radius-md);">
                    <p style="margin:0;font-size:0.85rem;">
                        ${state.hitmanSuccess 
                            ? 'Le Hitman a √©limin√© sa cible avec succ√®s !' 
                            : 'Le Hitman a surv√©cu jusqu\'√† la fin de la partie !'}
                    </p>
                </div>
            `;
        } else {
            content.innerHTML = `
                <div class="profile-card" style="border-color:rgba(34,197,94,0.5);">
                    <div class="profile-title" style="color:#22c55e;">Les Civils</div>
                    <p style="font-size:0.9rem;">Ont d√©masqu√© <strong>${hitman.name}</strong> !</p>
                </div>
                <div class="profile-card" style="margin-top:8px;">
                    <div class="profile-title">Le Hitman</div>
                    <p class="hint">Sa cible √©tait ${target.name}. Heureusement, les civils l'ont arr√™t√© √† temps !</p>
                </div>
            `;
        }
        
        // R√©sum√© des survivants
        const survivors = state.players.filter((p, idx) => !state.eliminatedPlayers.includes(idx));
        if (survivors.length > 0) {
            content.innerHTML += `
                <div style="margin-top:12px;">
                    <p style="font-size:0.8rem;color:var(--text-muted);margin-bottom:6px;">Survivants :</p>
                    <div style="display:flex;flex-wrap:wrap;gap:6px;">
                        ${survivors.map(s => `
                            <span class="pill" style="background:rgba(148,163,184,0.2);border-color:rgba(148,163,184,0.4);">
                                ${s.name} ${s.role === 'hitman' ? '(Hitman)' : '(Civil)'}
                            </span>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        showScreen('screen-end');
    }
    // NOUVELLE FONCTION : Afficher instructions avant le mini-jeu
    function showMinigameInstructions(type, callback) {
        const container = $('minigameContent');
        
        const instructions = {
            memory: {
                title: "üß† Jeu de M√©moire",
                desc: "Trouve toutes les paires de cartes identiques",
                howToWin: "Associe les 6 paires le plus rapidement possible",
                icon: "üé¥"
            },
            reflex: {
                title: "‚ö° Test de R√©flexe",
                desc: "Clique d√®s que le cercle devient vert !",
                howToWin: "R√©agis en moins de 800ms pour gagner",
                icon: "üéØ"
            },
            colorcode: {
                title: "üé® Code Couleur",
                desc: "M√©morise la s√©quence puis reproduis-la",
                howToWin: "Retrouve l'ordre exact des 4 symboles",
                icon: "üß©"
            },
            puzzle: {
                title: "üî¢ Puzzle Num√©rique",
                desc: "Range les chiffres dans l'ordre croissant",
                howToWin: "Du plus petit (‚ë†) au plus grand (‚ë•)",
                icon: "üé≤"
            }
        };
        
        const info = instructions[type];
        
        container.innerHTML = `
            <div style="text-align:center;padding:20px;">
                <div style="font-size:3rem;margin-bottom:12px;">${info.icon}</div>
                <h3 style="margin:0 0 8px 0;font-size:1.1rem;">${info.title}</h3>
                <p style="margin:0 0 12px 0;font-size:0.85rem;color:var(--text-muted);">
                    ${info.desc}
                </p>
                <div style="background:var(--accent-soft);border:1px solid var(--accent);border-radius:12px;padding:10px;margin-bottom:16px;">
                    <p style="margin:0;font-size:0.8rem;color:var(--accent);">
                        <strong>üéØ Pour gagner :</strong> ${info.howToWin}
                    </p>
                </div>
                <button class="btn btn-primary btn-full" id="btnStartMinigame">
                    C'est parti ! üöÄ
                </button>
            </div>
        `;
        
        $('btnStartMinigame').addEventListener('click', callback);
    }

    // ========== EVENT LISTENERS ==========
    $('btnSkipVote').addEventListener('click', () => {
        // On vide les votes √©ventuels
        state.votes = {};

        // Texte de r√©solution sp√©cial
        $('resolutionSubtitle').textContent =
            "Les joueurs ont choisi de ne pas √©liminer ce round.";

        const container = $('voteResults');
        container.innerHTML =
            '<p class="hint" style="text-align:center;margin-top:8px;">Aucun vote enregistr√© ce round.</p>';

        const elimDiv = $('eliminationReveal');
        if (elimDiv) elimDiv.style.display = 'none';

        showScreen('screen-resolution');
    });

    $('btnSetupNext').addEventListener('click', () => {
        const count = parseInt($('playerCount').value, 10);
        state.numPlayers = count;
        createPlayersInputs();
        showScreen('screen-names');
    });

    $('btnNamesBack').addEventListener('click', () => {
        showScreen('screen-setup');
    });

    $('btnRevealClue').addEventListener('click', () => {
        if (state.lastClueIndex == null) return;
        const entry = state.journal[state.lastClueIndex];
        if (!entry) return;

        entry.public = true;                 // devient visible dans le journal
        $('clueActionsRow').style.display = 'none';
    });

    $('btnKeepClue').addEventListener('click', () => {
        // On ne modifie PAS entry.public (reste false = priv√©)
        $('clueActionsRow').style.display = 'none';
    });

    $('btnStartGame').addEventListener('click', () => {
        readPlayerNames();
        generateProfiles();
        assignRolesAndContract();
        state.currentRevealIndex = 0;
        updatePassScreen();
        showScreen('screen-pass');
    });

    $('btnRevealForPlayer').addEventListener('click', () => {
        renderPlayerView();
        showScreen('screen-player-view');
    });

    $('btnPlayerDone').addEventListener('click', () => {
        state.currentRevealIndex += 1;
        if (state.currentRevealIndex >= state.players.length) {
            updateSummary();
            showScreen('screen-summary');
            // Auto-d√©marrer la phase d'investigation apr√®s 2 secondes
            setTimeout(() => {
                startInvestigationPhase();
            }, 2000);
        } else {
            updatePassScreen();
            showScreen('screen-pass');
        }
    });

    $('btnRestart').addEventListener('click', resetGame);

    // Nouveaux listeners pour les phases de jeu
    $('btnStartTurn').addEventListener('click', showPlayerTurn);

    $('btnEndTurn').addEventListener('click', endPlayerTurn);

    $('btnBackToInvestigation').addEventListener('click', () => {
        showScreen('screen-investigation');
    });
    
    // ========== MODIFICATION DANS btnAttemptKill (r√©v√©lation d'attribut) ==========
    // Remplacer la section existante par celle-ci :

    // DANS LE LISTENER btnAttemptKill :
    $('btnAttemptKill').addEventListener('click', () => {
        const select = $('hitmanTargetSelect');
        const targetIdx = parseInt(select.value);
        
        if (isNaN(targetIdx)) {
            alert('Choisis une cible !');
            return;
        }
        
        state.hitmanAttempted = true;
        const isCorrect = targetIdx === state.targetIndex;
        
        if (isCorrect) {
            state.hitmanSuccess = true;
            $('hitmanAction').innerHTML = `
                <div class="card" style="border-color:rgba(34,197,94,0.6);background:radial-gradient(circle at top left, rgba(34,197,94,0.15), transparent 50%);">
                    <div class="card-title" style="color:#22c55e;">‚úÖ Cible √©limin√©e !</div>
                    <p style="font-size:0.85rem;">Tu as r√©ussi ton contrat. La partie va se terminer.</p>
                </div>
            `;
        } else {
            // ========== CORRECTION CRITIQUE ICI ==========
            // R√©v√©lation d'UN attribut du HITMAN (pas de la cible !)
            const hitman = state.players[state.hitmanIndex];
            const attrs = ['gender', 'accessory', 'job', 'trait'];
            const revealedAttr = attrs[Math.floor(Math.random() * attrs.length)];
            
            let label, val;
            switch(revealedAttr) {
                case 'gender': 
                    label = 'Genre'; 
                    val = hitman.profile.gender;  // SON PROFIL
                    break;
                case 'accessory': 
                    label = 'Accessoire'; 
                    val = hitman.profile.accessory;
                    break;
                case 'job': 
                    label = 'M√©tier'; 
                    val = hitman.profile.job;
                    break;
                case 'trait': 
                    label = 'Caract√®re'; 
                    val = hitman.profile.trait;
                    break;
            }
            
            // Ajouter au journal comme indice public V√âRIFI√â
            state.journal.push({
                round: state.currentRound,
                player: 'Syst√®me',
                type: 'penalty',
                targetPlayer: hitman.name,
                targetIndex: state.hitmanIndex,
                attribute: label,
                attributeKey: revealedAttr,
                value: val,
                isFalse: false,
                isPenalty: true,
                reliability: 'verified', // FIABILIT√â MAXIMALE
                public: false
            });
            
            $('hitmanAction').innerHTML = `
                <div class="card" style="border-color:rgba(249,115,115,0.6);background:radial-gradient(circle at top left, rgba(249,115,115,0.15), transparent 50%);">
                    <div class="card-title" style="color:var(--danger);">‚ùå Mauvaise cible !</div>
                    <p style="font-size:0.85rem;">Tu as √©limin√© ${state.players[targetIdx].name}, qui n'√©tait pas ta cible.</p>
                    <p style="font-size:0.85rem;margin-top:8px;"><strong>üö® P√âNALIT√â :</strong> Un de TES attributs a √©t√© r√©v√©l√© √† tous les joueurs !</p>
                    <div style="background:var(--danger);color:#000;padding:12px;border-radius:8px;margin-top:8px;font-weight:600;">
                        ${label} du Hitman = ${val}
                    </div>
                    <p style="font-size:0.75rem;margin-top:8px;color:var(--text-muted);">
                        Cet indice appara√Ætra dans le journal avec le marqueur <span style="color:var(--success);">‚úì V√âRIFI√â</span>
                    </p>
                </div>
            `;
        }
        
        stopTurnTimer();
        $('minigameContainer').style.display = 'none';
        $('btnEndTurn').style.display = 'inline-flex';
    });

    $('btnUseWitness').addEventListener('click', () => {
        const playerIdx = state.investigationOrder[state.currentPlayerTurn];
        const player = state.players[playerIdx];

        if (state.witnessUses[playerIdx]) {
            alert('Tu as d√©j√† utilis√© ton t√©moin.');
            return;
        }

        state.witnessUses[playerIdx] = true;

        let clue = generateClue(playerIdx);
        if (!clue) {
            alert('Aucun t√©moin disponible pour ce tour.');
            return;
        }

        // T√©moin = indice TOUJOURS vrai
        clue = {
            ...clue,
            isFalse: false,
            reliability: 'verified',
            type: 'witness'
        };

        state.clueGivenThisTurn = true;
        stopTurnTimer();
        setBackgroundMood('success');

        const entry = {
            round: state.currentRound,
            player: player.name,
            ...clue,
            public: false // PRIV√â tant qu‚Äôil ne l‚Äôa pas r√©v√©l√©
        };
        state.journal.push(entry);
        state.lastClueIndex = state.journal.length - 1;

        // UI
        $('minigameContainer').style.display = 'none';
        $('witnessAction').style.display = 'none';

        const clueBox = $('clueReveal');
        clueBox.style.display = 'block';
        $('clueText').innerHTML = `
            <strong>üëÅÔ∏è T√©moignage fiable</strong><br>
            ${clue.targetPlayer} : ${clue.attribute} = ${clue.value}
        `;

        $('clueActionsRow').style.display = 'flex'; // boutons R√©v√©ler / Garder
        $('btnEndTurn').style.display = 'inline-flex';
    });


    $('btnGoToVote').addEventListener('click', () => {
        // R√©initialiser l'ordre de vote
        state.voteOrder = state.investigationOrder.filter(idx => !state.eliminatedPlayers.includes(idx));
        state.currentVoter = 0;
        
        // Pr√©parer l'√©cran de vote
        const container = $('voteButtons');
        container.innerHTML = '';
        container.style.display = 'flex';
        
        const alivePlayers = state.players.filter((p, idx) => !state.eliminatedPlayers.includes(idx));
        
        // Message pour le premier votant
        alert(`Passe le t√©l√©phone √† ${state.players[state.voteOrder[0]].name} pour le vote.`);
        
        // G√©n√©rer les boutons de vote
        alivePlayers.forEach(player => {
            const btn = document.createElement('button');
            btn.className = 'btn btn-ghost';
            btn.style.cssText = 'width:100%;text-align:left;justify-content:flex-start;margin-bottom:6px;';
            btn.innerHTML = `
                <span style="width:28px;height:28px;border-radius:50%;background:var(--accent-soft);display:flex;align-items:center;justify-content:center;margin-right:10px;font-size:0.85rem;">
                    ${player.name.charAt(0)}
                </span>
                ${player.name}
            `;
            btn.addEventListener('click', () => {
                const voter = state.players[state.voteOrder[state.currentVoter]];
                state.votes[voter.id] = player.id;
                
                // Afficher confirmation temporairement
                $('voteConfirmation').style.display = 'block';
                $('votedPlayerName').textContent = player.name;
                $('voteButtons').style.display = 'none';
                
                state.currentVoter++;
                
                setTimeout(() => {
                    if (state.currentVoter >= state.voteOrder.length) {
                        // Tous ont vot√©
                        $('btnRevealVotes').style.display = 'inline-flex';
                        $('voteConfirmation').innerHTML = '<p style="color:var(--accent);">Tous les votes sont enregistr√©s !</p>';
                    } else {
                        // Passer au suivant
                        $('voteConfirmation').style.display = 'none';
                        $('voteButtons').style.display = 'flex';
                        alert(`Passe le t√©l√©phone √† ${state.players[state.voteOrder[state.currentVoter]].name}`);
                    }
                }, 800);
            });
            container.appendChild(btn);
        });
        
        $('voteConfirmation').style.display = 'none';
        $('btnRevealVotes').style.display = 'none';
        showScreen('screen-vote');
    });

    $('btnRevealVotes').addEventListener('click', revealVotes);

    $('btnNextRound').addEventListener('click', nextRound);

    $('btnNewGame').addEventListener('click', resetGame);

    function resetGame() {
        // Reset complet
        state.numPlayers = 3;
        state.players = [];
        state.hitmanIndex = null;
        state.targetIndex = null;
        state.contractAttributes = [];
        state.currentRevealIndex = 0;
        state.gamePhase = 'setup';
        state.currentRound = 0;
        state.currentPlayerTurn = 0;
        state.investigationOrder = [];
        state.journal = [];
        state.eliminatedPlayers = [];
        state.hitmanAttempted = false;
        state.hitmanSuccess = false;
        state.votes = {};
        state.gameOver = false;
        state.winner = null;
        state.voteOrder = null;
        state.currentVoter = 0;
        
        // NOUVEAU v2.0
        state.hitmanAbilities = {
            fakeClueUsed: false,
            fakeCluesRemaining: 1
        };
        state.currentJournalFilter = 'all';
        state.currentJournalView = 'list';
        state.witnessAsked = false;
        state.witnessAnswer = null;
        
        $('playerCount').value = '3';
        showScreen('screen-setup');
    }
    
    // Choix d'action (Mini-jeu ou T√©moin)
    $('btnActionMinigame').addEventListener('click', () => {
        startMinigameDirectly();
    });

    $('btnActionWitness').addEventListener('click', () => {
        $('actionChoice').style.display = 'none';
        $('witnessSystem').style.display = 'block';
        
        // Remplir la liste des joueurs
        const playerIdx = state.investigationOrder[state.currentPlayerTurn];
        const select = $('witnessTargetSelect');
        select.innerHTML = '<option value="">-- Choisir un joueur --</option>';
        
        state.players.forEach((p, idx) => {
            if (idx !== playerIdx && !state.eliminatedPlayers.includes(idx)) {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = p.name;
                select.appendChild(opt);
            }
        });
    });

    // Poser une question de t√©moin
    $('btnAskWitness').addEventListener('click', () => {
        const targetIdx = parseInt($('witnessTargetSelect').value);
        const questionAttr = $('witnessQuestionSelect').value;
        
        if (isNaN(targetIdx) || !questionAttr) {
            alert('Choisis un joueur et une question !');
            return;
        }
        
        const target = state.players[targetIdx];
        let attrLabel, attrValue;
        
        switch(questionAttr) {
            case 'gender': attrLabel = 'Genre'; attrValue = target.profile.gender; break;
            case 'accessory': attrLabel = 'Accessoire'; attrValue = target.profile.accessory; break;
            case 'job': attrLabel = 'M√©tier'; attrValue = target.profile.job; break;
            case 'trait': attrLabel = 'Caract√®re'; attrValue = target.profile.trait; break;
        }
        
        // Afficher la r√©ponse
        $('witnessSystem').style.display = 'none';
        const answerDiv = $('witnessAnswer');
        answerDiv.style.display = 'block';
        answerDiv.innerHTML = `
            <div class="card" style="border-color: rgba(56,189,248,0.6);">
                <div class="profile-title">üí¨ R√©ponse de ${target.name}</div>
                <p style="font-size:0.9rem;margin:6px 0;">
                    <strong>${attrLabel} :</strong> ${attrValue}
                </p>
                <p style="font-size:0.75rem;color:var(--text-muted);margin-top:6px;">
                    <span class="reliability-claimed">‚ö†</span> Cet indice est d√©clar√© (le joueur peut mentir, mais c'est risqu√©).
                </p>
            </div>
        `;
        
        // Ajouter au journal
        const playerIdx = state.investigationOrder[state.currentPlayerTurn];
        const clue = {
            round: state.currentRound,
            player: state.players[playerIdx].name,
            type: 'witness',
            targetPlayer: target.name,
            targetIndex: targetIdx,
            attribute: attrLabel,
            attributeKey: questionAttr,
            value: attrValue,
            isFalse: false,
            reliability: 'claimed'
        };
        
        state.journal.push(clue);
        state.players[playerIdx].clues.push(clue);
        state.witnessAsked = true;
        
        // Afficher le bouton terminer
        $('btnEndTurn').style.display = 'inline-flex';
    });

    // Capacit√© Hitman : Planter un faux indice
    $('btnPlantFakeClue').addEventListener('click', () => {
        if (state.hitmanAbilities.fakeClueUsed) {
            alert('Tu as d√©j√† utilis√© cette capacit√© !');
            return;
        }
        
        // Choisir un joueur al√©atoire (pas le Hitman)
        const otherPlayers = state.players
            .map((p, idx) => idx)
            .filter(idx => idx !== state.hitmanIndex && !state.eliminatedPlayers.includes(idx));
        
        if (otherPlayers.length === 0) return;
        
        const targetIdx = otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
        const target = state.players[targetIdx];
        
        // Choisir un attribut et une valeur FAUSSE
        const attrs = ['gender', 'accessory', 'job', 'trait'];
        const attr = attrs[Math.floor(Math.random() * attrs.length)];
        
        let attrLabel, correctValue, possibleValues, fakeValue;
        
        switch(attr) {
            case 'gender': 
                attrLabel = 'Genre'; 
                correctValue = target.profile.gender;
                possibleValues = genders;
                break;
            case 'accessory': 
                attrLabel = 'Accessoire'; 
                correctValue = target.profile.accessory;
                possibleValues = accessories;
                break;
            case 'job': 
                attrLabel = 'M√©tier'; 
                correctValue = target.profile.job;
                possibleValues = jobs;
                break;
            case 'trait': 
                attrLabel = 'Caract√®re'; 
                correctValue = target.profile.trait;
                possibleValues = traits;
                break;
        }
        
        const otherValues = possibleValues.filter(v => v !== correctValue);
        fakeValue = otherValues[Math.floor(Math.random() * otherValues.length)];
        
        // Ajouter au journal comme indice "suspect" mais sans r√©v√©ler que c'est le Hitman
        const fakeClue = {
            round: state.currentRound,
            player: 'Syst√®me',
            type: 'fake_planted',
            targetPlayer: target.name,
            targetIndex: targetIdx,
            attribute: attrLabel,
            attributeKey: attr,
            value: fakeValue,
            isFalse: true,
            reliability: 'suspicious'
        };
        
        state.journal.push(fakeClue);
        state.hitmanAbilities.fakeClueUsed = true;
        
        // Confirmation
        alert(`‚úÖ Faux indice plant√© !\n\n"${target.name} - ${attrLabel}: ${fakeValue}" a √©t√© ajout√© au journal.\n\nLes civils ne sauront pas que c'est faux !`);
        
        updateHitmanAbilities();
    });

    // Filtres du journal
    $('journalFilters').addEventListener('click', (e) => {
        if (!e.target.classList.contains('filter-btn')) return;
        
        // Retirer active de tous
        $('journalFilters').querySelectorAll('.filter-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Activer celui cliqu√©
        e.target.classList.add('active');
        state.currentJournalFilter = e.target.dataset.filter;
        
        renderJournalList();
    });

    // Basculer entre vue liste et vue tableau
    $('btnViewList').addEventListener('click', () => {
        $('btnViewList').classList.add('active');
        $('btnViewTable').classList.remove('active');
        $('journalListView').style.display = 'block';
        $('journalTableView').style.display = 'none';
        state.currentJournalView = 'list';
    });

    $('btnViewTable').addEventListener('click', () => {
        $('btnViewList').classList.remove('active');
        $('btnViewTable').classList.add('active');
        $('journalListView').style.display = 'none';
        $('journalTableView').style.display = 'block';
        state.currentJournalView = 'table';
    });

    // ========== 7. NOUVEAU : GESTION DES CAPACIT√âS HITMAN ==========
    // AJOUTER cette fonction

    function updateHitmanAbilities() {
        const fakeClueBtn = $('btnPlantFakeClue');
        const fakeClueAbility = $('fakeClueAbility');
        
        if (state.hitmanAbilities.fakeClueUsed) {
            fakeClueBtn.disabled = true;
            fakeClueBtn.style.opacity = '0.5';
            fakeClueAbility.classList.add('used');
        } else {
            fakeClueBtn.disabled = false;
            fakeClueBtn.style.opacity = '1';
            fakeClueAbility.classList.remove('used');
        }
    }
    
    // ========== 8. NOUVEAU : D√âMARRER MINI-JEU DIRECTEMENT ==========
    // AJOUTER cette fonction

    function startMinigameDirectly() {
        $('actionChoice').style.display = 'none';
        $('minigameContainer').style.display = 'block';
        
        // G√©n√©rer mini-jeu al√©atoire (4 types maintenant)
        const r = Math.random();
        let minigameType;
        if (r < 0.25) minigameType = 'memory';
        else if (r < 0.5) minigameType = 'reflex';
        else if (r < 0.75) minigameType = 'colorcode';
        else minigameType = 'puzzle';
        
        renderMinigame(minigameType);
        startTurnTimer();
    }
    // ========== FONCTION CONFETTIS SIMPLE (SANS THREE.JS) ==========

    function createSimpleConfetti() {
        const colors = ['#38bdf8', '#22c55e', '#facc15', '#f97373', '#a78bfa'];
        
        for (let i = 0; i < 30; i++) {
            const confetti = document.createElement('div');
            confetti.style.cssText = `
                position: fixed;
                width: 8px;
                height: 8px;
                background: ${colors[Math.floor(Math.random() * colors.length)]};
                top: 50%;
                left: 50%;
                border-radius: 50%;
                pointer-events: none;
                z-index: 9999;
            `;
            
            document.body.appendChild(confetti);
            
            const angle = (Math.random() * 360) * (Math.PI / 180);
            const velocity = Math.random() * 400 + 200;
            const vx = Math.cos(angle) * velocity;
            const vy = Math.sin(angle) * velocity - 300;
            
            animateConfetti(confetti, vx, vy);
        }
    }

    function animateConfetti(el, vx, vy) {
        let x = 0, y = 0;
        const gravity = 1000; // px/s¬≤
        let startTime = Date.now();
        
        function update() {
            const elapsed = (Date.now() - startTime) / 1000;
            
            x = vx * elapsed;
            y = vy * elapsed + 0.5 * gravity * elapsed * elapsed;
            
            el.style.transform = `translate(${x}px, ${y}px)`;
            el.style.opacity = Math.max(0, 1 - elapsed / 1.5);
            
            if (elapsed < 1.5) {
                requestAnimationFrame(update);
            } else {
                el.remove();
            }
        }
        
        update();
    }

    // ========== 9. NOUVEAU : AFFICHAGE DES INDICES DU JOUEUR ==========
    // AJOUTER cette fonction

    function renderPlayerCluesFor(playerIdx) {
        const player = state.players[playerIdx];
        const cluesDiv = $('playerClues');
        const cluesList = $('playerCluesList');
        
        if (player.clues && player.clues.length > 0) {
            cluesDiv.style.display = 'block';
            cluesList.innerHTML = player.clues.map(c => {
                const reliabilityIcon = c.reliability === 'verified' ? '‚úì' :
                                    c.reliability === 'claimed' ? '‚ö†' : '‚úó';
                const reliabilityClass = c.reliability === 'verified' ? 'reliability-verified' :
                                    c.reliability === 'claimed' ? 'reliability-claimed' : 'reliability-suspicious';
                return `
                    <div class="clue-card">
                        <span class="${reliabilityClass}">${reliabilityIcon}</span>
                        <strong>${c.targetPlayer}</strong> : ${c.attribute} = ${c.value}
                    </div>
                `;
            }).join('');
        } else {
            cluesDiv.style.display = 'none';
        }
    }

    // Enregistrement du service worker pour la PWA
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/hitman-social/service-worker.js')
                .then(reg => {
                    console.log('Service worker enregistr√© avec le scope :', reg.scope);
                })
                .catch(err => {
                    console.error('√âchec de l\'enregistrement du service worker :', err);
                });
        });
    }
    let bg3dMaterial = null;
    // ===== Fond 3D l√©ger avec particules =====
    function initBackground3D() {
        if (typeof THREE === 'undefined') return;

        const container = document.getElementById('bg3d-container');
        const width = window.innerWidth;
        const height = window.innerHeight;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Particules
        const particlesCount = 120;
        const positions = new Float32Array(particlesCount * 3);
        for (let i = 0; i < particlesCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 18;
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({
            size: 0.06,
            color: 0x38bdf8, // bleu par d√©faut
            transparent: true,
            opacity: 0.7
        });
        window.bg3dMaterial = material; // juste apr√®s avoir cr√©√© ton PointsMaterial

        // garder une r√©f√©rence globale
        bg3dMaterial = material;

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        function onResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', onResize);

        function animate() {
            requestAnimationFrame(animate);
            points.rotation.y += 0.0008;
            points.rotation.x += 0.0003;
            renderer.render(scene, camera);
        }

        animate();
    }
    function setBackgroundMood(mode) {
        if (!bg3dMaterial) return;

        // couleurs en hex
        const BLUE = 0x38bdf8;
        const GREEN = 0x22c55e;
        const RED = 0xef4444;

        if (mode === 'success') {
            bg3dMaterial.color.setHex(GREEN);
        } else if (mode === 'fail') {
            bg3dMaterial.color.setHex(RED);
        } else {
            // 'default' ou tout autre
            bg3dMaterial.color.setHex(BLUE);
        }
    }
    window.bg3dMaterial = window.bg3dMaterial || null;
    function setBackgroundMood(mode) {
        const body = document.body;
        body.classList.remove('mood-default', 'mood-success', 'mood-fail');

        if (mode === 'success') {
            body.classList.add('mood-success');
        } else if (mode === 'fail') {
            body.classList.add('mood-fail');
        } else {
            body.classList.add('mood-default');
        }

        // Si tu as un mat√©riau de particules Three.js, adapte aussi sa couleur
        if (window.bg3dMaterial) {
            const BLUE  = 0x38bdf8;
            const GREEN = 0x22c55e;
            const RED   = 0xef4444;

            if (mode === 'success') {
                window.bg3dMaterial.color.setHex(GREEN);
            } else if (mode === 'fail') {
                window.bg3dMaterial.color.setHex(RED);
            } else {
                window.bg3dMaterial.color.setHex(BLUE);
            }
        }
    }
    // optionnel : exposer sur window pour d√©bugger dans la console
    window.setBackgroundMood = setBackgroundMood;
    // Lancer le fond 3D au chargement
    window.addEventListener('load', initBackground3D);

    function handleBonusAnswer(isCorrect, chosenValue, correctValue, targetPlayerIndex) {
        const playerIdx = state.investigationOrder[state.currentPlayerTurn];
        const player = state.players[playerIdx];
        const target = state.players[targetPlayerIndex];

        if (isCorrect) {
            // Indice bonus FIABLE
            const entry = {
                round: state.currentRound,
                player: player.name,
                targetPlayer: target.name,
                targetIndex: targetPlayerIndex,
                attribute: currentBonusAttributeLabel,
                value: correctValue,
                isFalse: false,
                reliability: 'verified',
                type: 'bonus_correct',
                public: false
            };
            state.journal.push(entry);
            state.lastClueIndex = state.journal.length - 1;

            // UI : message de succ√®s + attribut (tu peux garder ton texte actuel)
            $('clueReveal').style.display = 'block';
            $('clueText').innerHTML = `
                <strong>‚úÖ Correct</strong><br>
                ${target.name} : ${currentBonusAttributeLabel} = ${correctValue}
            `;
            $('clueActionsRow').style.display = 'flex';
            $('btnEndTurn').style.display = 'inline-flex';

        } else {
            // On enregistre SEULEMENT la MAUVAISE d√©claration comme indice suspect
            const entry = {
                round: state.currentRound,
                player: player.name,
                targetPlayer: target.name,
                targetIndex: targetPlayerIndex,
                attribute: currentBonusAttributeLabel,
                value: chosenValue, // sa r√©ponse (fausse)
                isFalse: true,
                reliability: 'suspicious',
                type: 'bonus_wrong',
                public: false
            };
            state.journal.push(entry);
            state.lastClueIndex = state.journal.length - 1;

            // UI : message g√©n√©rique, SANS montrer la bonne r√©ponse
            $('clueReveal').style.display = 'block';
            $('clueText').innerHTML = `
                <strong style="color:var(--danger);">‚ùå Incorrect</strong><br>
                Ta r√©ponse est enregistr√©e comme indice suspect dans le journal.
            `;
            $('clueActionsRow').style.display = 'flex';
            $('btnEndTurn').style.display = 'inline-flex';
        }
    }
})();
</script>
</body>
</html>